export const title = "Chapter 00 - Bitcoin Protocol Basics";
export const description = "Learn the basics of the Bitcoin protocol, including unspent transaction outputs (UTXOs) and the concept of the mempool, in this introductory chapter.";

# Chapter 00 - Bitcoin Protocol Basics

There are many aspects of the bitcoin protocol that isnt needed to understand the CC contracts dependence on it. Such details will not be discussed. The primary aspect is the utxo, unspent transaction output. Just a fancy name for `txid/vout`, so when you sendtoaddress some coins, it creates a `txid` and the first output is `vout.0`, combine it and `txid/0` is a specific utxo.

Of course, to understand even this level of detail requires that you understand what a `txid` is, but there are plenty of reference materials on that. It is basically the 64 char long set of letters and numbers that you get when you send funds.

Implicit with the utxo is that it prevents double spends. Once you spend a utxo, you cant spend it again. This is quite an important characteristic and while advanced readers will point out chain reorgs can allow a double spend, we will not confuse the issue with such details. The important thing is that given a blockchain at a specific height's blockhash, you can know if a `txid/vout` has been spent or not.

There are also the transactions that are in memory waiting to be mined, the mempool. And it is possible for the utxo to be spent by a `tx` in the mempool. However since it isnt confirmed yet, it is still unspent at the current height, even if we are pretty sure it will be spent in the next block.

A useful example is to think about a queue of people lined up to get into an event. They need to have a valid ticket and also to get into the queue. After some time passes, they get their ticket stamped and allowed into the event.

In the utxo case, the ticket is the spending transaction and the event is the confirmed blockchain. The queue is the mempool.
export const title = "Chapter 01 - OP_CHECKCRYPTOCONDITION";
export const description = "Explore Bitcoin payment scripts: P2PKH, P2SH, and the introduction of OP_CHECKCRYPTOCONDITION opcode for CryptoConditions.";

# Chapter 01 - OP\_CHECKCRYPTOCONDITION

In the prior chapter the utxo was explained. However, the specific mechanism used to send a payment was not explained. Contrary to what most people might think, on the blockchain there are not entries that say "pay X amount to address". Instead what exists is a bitcoin script that must be satisfied in order for the funds to be able to be spent.

Originally, there was the pay to pubkey script:

```bash
<pubkey> <checksig>
```

About as simple of a payment script that you can get. Basically the pubkey's signature is checked and if it is valid, you get to spend it. One problem satoshi realized was that with Quantum Computers such payment scripts are vulnerable! So, he made a way to have a cold address, ie. an address whose pubkey isnt known. At least it isnt known until it is spent, so it is only Quantum resistant prior to the first spend. This line of reasoning is why we have one time use addresses and a new change address for each transaction. Maybe in some ways, this is too forward thinking as it makes things a lot more confusing to use and easier to lose track of all the required private keys.

However, it is here to stay and its script is:

```bash
<hash the pubkey> <pubkey> <verify hash matches> <checksig>
```

With this, the blockchain has what maps to "pay to address", just that the address is actually a base58 encoded (prefix + pubkeyhash). Hey, if it wasnt complicated, it would be easy!

In order to spend a `p2pkh` (pay to pubkey hash) utxo, you need to divulge the pubkey in addition to having a valid signature. After the first spend from an address, its security is degraded to `p2pk` (pay to pubkey) as its pubkey is now known. The net result is that each reused address takes 25 extra bytes on the blockchain, and that is why for addresses that are expected to be reused, I just use the p2pk script.

Originally, bitcoin allowed any type of script opcodes to be used directly. The problem was some of them caused problems and satoshi decided to disable them and only allow standard forms of payments. Thus the `p2pk` and `p2pkh` became 99%+ of bitcoin transactions. However, going from having a fully scriptable language that can create countless payment scripts (and bugs!), to having just 2 . . . well it was a "short term" limitation. It did last for some years but eventually a compromise `p2sh` script was allowed to be standard. This is a pay to script hash, so it can have a standard format as the normal `p2pkh`, but have infinitely more flexibility.

```bash
<hash the script> <script> <verify hash matches>
```

Wait, something is wrong! If it was just that, then anybody that found out what the required script (called redeemscript) was, they could just spend it. I forgot to say that the redeemscript is then used to determine if the payment can be spent or not. So you can have a normal `p2pk` or `p2pkh` redeemscript inside a `p2sh` script.

OK, I know that just got really confusing. Let us have a more clear example:

```bash
redeemscript <- pay to pubkey
```

`p2sh` becomes the hash of the redeem script + the compares

So to spend it, you need to divulge the redeemscript, which in turn requires you to divulge the pubkey. Put it all together and the `p2sh` mechanism verifies you not only had the correct redeemscript by comparing its hash, but that when the redeemscript is run, it is satisfied. In this case, that the pubkey's signature was valid.

If you are still following, there is some good news! `OP_CHECKCRYPTOCONDITION` scripts are actually simpler than `p2sh` scripts in some sense as there isnt this extra level of script inside a scripthash. [@libscott](https://github.com/libscott) implemented the addition of `OP_CHECKCRYPTOCONDITION` to the set of bitcoin opcodes and what it does is makes sure that a CryptoConditions script is properly signed.

Which gets us to the CryptoConditions specification, which is a monster of a [IETF (Internet standards)](https://datatracker.ietf.org/doc/html/draft-thomas-crypto-conditions-04) draft and has hundred(s) of pages of specification. I am sure you are happy to know that you dont really need to know about it much at all! Just know that you can create all sorts of cryptoconditions and its binary encoding can be used in a bitcoin utxo. If the standard CC contracts dont have the power you need, it is always possible to expand on it. So far, most all the CC contracts only need the power of a 1of1 CC script, which is 1 signature combined with custom constraints. The realtime payment channels CC is the only one of the reference CC contracts so far that didnt fit into this model, it needed a 1of2 CC script.

The best part is that all these opcode level things are not needed at all. I just wanted to explain it for those that need to know all the details of everything.
export const title = "Chapter 02 - CC Contract Basics";
export const description = "Explore the basics of CC contracts in blockchain, including eval codes, pubkey requirements, and address generation for each contract.";

# Chapter 02 - CC Contract Basics

Each CC contract has an eval code, this is just an arbitrary number that is associated with a specific CC contract. The details about a specific CC contract are all determined by the validation logic, that is ultimately what implements a CC contract.

However, unlike the normal bitcoin payments, where it is validated with only information in the transaction, a CC contract has the power to do pretty much anything. It has full access to the blockchain and even the mempool, though using mempool information is inherently more risky and needs to be done carefully or for exclusions, rather than inclusions.

However, this is the CC contract basics chapter, so let us ignore mempool issues and deal with just the basics. Fundamentally there is no structure for `OP_CHECKCRYPTOCONDITION` serialized scripts, but if you are like me, you want to avoid having to read and understand a 1000 page IETF standard. What we really want to do is have a logical way to make a new contract and have it be able to be coded and debugged in an efficient way.

That means to just follow a known working template and only changing the things where the existing templates are not sufficient, ie. the core differentiator of your CC contract.

In the [\~/komodo/src/cc/eval.h](https://github.com/jl777/komodo/blob/jl777/src/cc/eval.h) file all the eval codes are defined, currently:

```bash
#define FOREACH_EVAL(EVAL)             \
        EVAL(EVAL_IMPORTPAYOUT, 0xe1)  \
        EVAL(EVAL_IMPORTCOIN,   0xe2)  \
        EVAL(EVAL_ASSETS,   0xe3)  \
        EVAL(EVAL_FAUCET, 0xe4) \
        EVAL(EVAL_REWARDS, 0xe5) \
        EVAL(EVAL_DICE, 0xe6) \
        EVAL(EVAL_FSM, 0xe7) \
        EVAL(EVAL_AUCTION, 0xe8) \
        EVAL(EVAL_LOTTO, 0xe9) \
        EVAL(EVAL_HEIR, 0xea) \
        EVAL(EVAL_CHANNELS, 0xeb) \
        EVAL(EVAL_ORACLES, 0xec) \
        EVAL(EVAL_PRICES, 0xed) \
        EVAL(EVAL_PEGS, 0xee) \
        EVAL(EVAL_TRIGGERS, 0xef) \
        EVAL(EVAL_PAYMENTS, 0xf0) \
        EVAL(EVAL_GATEWAYS, 0xf1)
```

Ultimately, we will probably end up with all 256 eval codes used, for now there is plenty of room. I imagined that similar to my coins repo, we can end up with a much larger than 256 number of CC contracts and you select the 256 that you want active for your blockchain. That does mean any specific chain will be limited to "only" having 256 contracts. Since there seems to be so few actually useful contracts so far, this limit seems to be sufficient. I am told that the evalcode can be of any length, but the current CC contracts assumes it is one byte.

The simplest CC script would be one that requires a signature from a pubkey along with a CC validation. This is the equivalent of the pay to pubkey bitcoin script and is what most of the initial CC contracts use. Only the channels one needed more than this and it will be explained in its chapter.

We end up with CC scripts of the form (`evalcode`) + (`pubkey`) + (other stuff), dont worry about the other stuff, it is automatically handled with some handy internal functions. The important thing to note is that each CC contract of this form needs a single pubkey and eval code and from that we get the CC script. Using the standard bitcoin's "hash and make an address from it" method, this means that the same pubkey will generate a different address for each different CC contract!

This is an important point, so I will say it in a different way. In bitcoin there used to be uncompressed pubkeys which had both the right and left half combined, into a giant 64 byte pubkey. But since you can derive one from the other, compressed pubkeys became the standard, that is why you have bitcoin pubkeys of 33 bytes instead of 65 bytes. There is a 02, 03 or 04 prefix, to mean odd or even or big pubkey. This means there are two different pubkeys for each privkey, the compressed and uncompressed. And in fact you can have two different bitcoin protocol addresses that are spendable by the same privkey. If you use some paper wallet generators, you might have noticed this.

CC contracts are like that, where each pubkey gets a different address for each evalcode. It is the same pubkey, just different address due to the actual script having a different evalcode, it ends up with a different hash and thus a different address. Now funds send to a specific CC address is only accessible by that CC contract and must follow the rules of that contract.

I also added another very useful feature where the convention is for each CC contract to have a special address that is known to all, including its private key. Before you panic about publishing the private key, remember that to spend a CC output, you need to properly sign it AND satisfy all the rules. By everyone having the privkey for the CC contract, everybody can do the "properly sign" part, but they still need to follow the rest of the rules.

From a user's perspective, there is the global CC address for a CC contract and some contracts also use the user pubkey's CC address. Having a pair of new addresses for each contract can get a bit confusing at first, but eventually we will get easy to use GUI that will make it all easy to use.
export const title = "Chapter 03 - CC vins and vouts";
export const description = "Discover the power and flexibility of CC vins and vouts in blockchain transactions, enabling complex constraints and possibilities for CC contracts.";

# Chapter 03 - CC vins and vouts

You might want to review the bitcoin basics and other materials to refresh about how bitcoin outputs become inputs. It is a bit complicated, but ultimately it is about one specific amount of coins that are spent, once spent it is combined with the other coins that are also spent in that transaction and then various outputs are created.

```bash
vin0 + vin1 + vin2 -> vout0 + vout1
```

That is a 3 input, 2 output transaction. The value from the three inputs are combined and then split into vout0 and vout1, each of the vouts gets a spend script that must be satisfied to be able to be spent. Which means for all three of out vins, all the requirements (as specified in the output that created them) are satisfied.

Yes, I know this is a bit too complicated without a nice chart, so we will hope that a nice chart is added here:

```bash
Placeholder text : [nice chart goes here]
```

Out of all the aspects of the CC contracts, the flexibility that different vins and vouts created was the biggest surprise. When I started writing the first of these a month ago, I had no idea the power inherent in the smart utxo contracts. I was just happy to have a way to lock funds and release them upon some specific conditions.

After the assets/tokens CC contract, I realized that it was just a tip of the iceberg. I knew it was Turing complete, but after all these years of restricted bitcoin script, to have the full power of any arbitrary algorithm, it was eye opening. Years of writing blockchain code and having really bad consequences with every bug naturally makes you gun shy about doing aggressive things at the consensus level. And that is the way it should be, if not very careful, some really bad things can and do happen. The foundation of building on top of the existing (well tested and reliable) utxo system is what makes the CC contracts less likely for the monster bugs. That being said, lack of validation can easily allow an improperly coded CC contract to have its funds drained.

The CC contract breaks out of the standard limitations of a bitcoin transaction. Already, what I wrote explains the reason, but it was not obvious even to me at first, so likely you might have missed it too. If you are wondering what on earth I am talking about, THAT is what I am talking about!

To recap, we have now a new standard bitcoin output type called a CC output. Further, there can be up to 256 different types of CC outputs active on any given blockchain. We also know that to spend any output, you need to satisfy its spending script, which in our case is the signature and whatever constraints the CC validation imposes. We also have the convention of a globally shared keypair, which gives us a general CC address that can have funds sent to it, along with a user pubkey specific CC address.

Let us go back to the 3+2 transaction example:

```bash
vin0 + vin1 + vin2 -> vout0 + vout1
```

Given the prior paragraph, try to imagine the possibilities the simple 3+2 transaction can be. Each vin could be a normal vin, from the global contract address, the user's CC address and the vouts can also have this range. Theoretically, there can be 257 \* 257 \* 257 \* 257 \* 257 forms of a 3+2 transaction!

In reality, we really dont want that much degrees of freedom as it will ensure a large degree of bugs! So we need to reduce things to a more manageable level where there are at most 3 types for each, and preferably just 1 type. That will make the job of validating it much simpler and simple is better as long as we dont sacrifice the power. We dont.

Ultimately the CC contract is all about how it constrains its inputs, but before it can constrain them, they need to be created as outputs. More about this in the CC validation chapter.
export const title = "Chapter 04 - CC RPC Extensions";
export const description = "Learn about the RPC extensions in CC contracts, enabling the creation and invocation of contracts through RPC calls for increased flexibility and functionality.";

# Chapter 04 - CC RPC Extensions

Currently, CC contracts need to be integrated at the source level. This limits who is able to create and add new CC contracts, which at first is good, but eventually will be a too strict limitation. The runtime bindings chapter will touch on how to break out of the source based limitation, but there is another key interface level, the RPC.

By convention, each CC contract adds an associated set of rpc calls to the `komodo-cli`. This not only simplifies the creation of the CC contract transactions, it further will allow dapps to be created just via rpc calls. That will require there being enough foundational CC contracts already in place. As we find new usecases that cannot be implemented via rpc, then a new CC contract is made that can handle that (and more) and the power of the rpc level increases. This is a long term process.

The typical rpc calls that are added `<CC>address`, `<CClist>`, `<CCinfo>` return the various special CC addresses, the list of CC contract instances and info about each CC contract instance. Along with an rpc that creates a CC instance and of course the calls to invoke a CC instance.

The role of the rpc calls are to create properly signed `rawtransactions` that are ready for broadcasting. This then allows using only the rpc calls to not only invoke but to create a specific instance of a CC. The faucet contract is special in that it only has a single instance, so some of these rpc calls are skipped.

So, there is no MUSTHAVE rpc calls, just a sane convention to follow so it fits into the general pattern.

One thing that I forgot to describe was how to create a special CC address and even though this is not really an rpc issue, it is kind of separate from the core CC functions, so I will show how to do it here:

```bash
const char *FaucetCCaddr = "R9zHrofhRbub7ER77B7NrVch3A63R39GuC";
const char *FaucetNormaladdr = "RKQV4oYs4rvxAWx1J43VnT73rSTVtUeckk";
char FaucetCChexstr[67] = { "03682b255c40d0cde8faee381a1a50bbb89980ff24539cb8518e294d3a63cefe12" };
uint8_t FaucetCCpriv[32] = { 0xd4, 0x4f, 0xf2, 0x31, 0x71, 0x7d, 0x28, 0x02, 0x4b, 0xc7, 0xdd, 0x71, 0xa0, 0x39, 0xc4, 0xbe, 0x1a, 0xfe, 0xeb, 0xc2, 0x46, 0xda, 0x76, 0xf8, 0x07, 0x53, 0x3d, 0x96, 0xb4, 0xca, 0xa0, 0xe9 };
```

Above are the specifics for the faucet CC, but each one has the equivalent in [CCcustom.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/CCcustom.cpp). At the bottom of the file is a big switch statement where these values are copied into an in memory data structure for each CC type. This allows all the CC codebase to access these special addresses in a standard way.

In order to get the above values, follow these steps:

1.  use `getnewaddress` to get a new address and put that in the `<CC>Normaladdr = "";` line

2.  use `validateaddress` `<newaddress from A>` to get the pubkey, which is put into the `<CC>hexstr[67] = "";` line

3.  stop the daemon \[`komodod`] and start with `-pubkey=<pubkey from B>` and do a `<CC>address` rpc call. In the console you will get a printout of the hex for the privkey, assuming the if ( 0 ) in `Myprivkey()` is enabled ([CCutils.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/CCutils.cpp))

4.  update the `CCaddress` and `privkey` and dont forget to change the `-pubkey=` parameter

The first rpc command to add is `<CC>address` and to do that, add a line to [rpcserver.h](https://github.com/jl777/komodo/blob/jl777/src/rpc/server.h) and update the commands array in [rpcserver.cpp](https://github.com/jl777/komodo/blob/jl777/src/rpc/server.cpp)

In the [rpcwallet.cpp](https://github.com/jl777/komodo/blob/jl777/src/wallet/rpcwallet.cpp) file you will find the actual rpc functions, find one of the `<CC>address` ones, copy paste, change the eval code to your eval code and customize the function. Oh, and dont forget to add an entry into [eval.h](https://github.com/jl777/komodo/blob/jl777/src/cc/eval.h)

Now you have made your own CC contract, but it wont link as you still need to implement the actual functions of it. This will be covered in the following chapters.
export const title = "Chapter 05 - CC Validation";
export const description = "Understand the importance of CC validation in ensuring the correctness and integrity of CC transactions, along with guidelines for implementing effective validation rules.";

# Chapter 05 - CC Validation

CC validation is what its all about, not the "hokey pokey"!

Each CC must have its own validation function and when the blockchain is validating a transaction, it will call the CC validation code. It is totally up to the CC validation whether to validate it or not.

Any set of rules that you can think of and implement can be part of the validation. Make sure that there is no ambiguity! Make sure that all transactions that should be rejected are in fact rejected.

Also, make sure any rpc calls that create a CC transaction dont create anything that doesnt validate.

Really, that is all that needs to be said about validation that is generic, as it is just a concept and gets a dedicated function to determine if a transaction is valid or not.

For most of the initial CC contracts, I made a function code for various functions of the CC contract and add that along with the creation txid. That enables the validation of the transactions much easier, as the required data is right there in the opreturn.

You do need to be careful not to cause a deadlock as the CC validation code is called while already locked in the main loop of the bitcoin protocol. As long as the provided CC contracts are used as models, you should keep out of deadlock troubles.
export const title = "Chapter 06 - Faucet Example";
export const description = "Explore the Faucet example, a simple CC contract that allows users to receive a small amount of coins while implementing strict rules to prevent abuse.";

# Chapter 06 - Faucet Example

Finally, we are ready for the first actual example of a CC contract. The faucet. This is a very simple contract and it ran into some interesting bugs in the first incarnation.

The code in [\~/komodo/src/cc/faucet.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/faucet.cpp) is the ultimate documentation for it with all the details, so I will just address the conceptual issues here.

The idea is that people send funds to the faucet by locking it in faucet's global CC address and anybody is allowed to create a faucetget transaction that spends it.

There are only 7 functions in [faucet.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/faucet.cpp), a bit over 200 lines including comments. The first three are for validation, the last four for the rpc calls to use.

*   int64\_t IsFaucetvout(struct CCcontract\_info \*cp,const CTransaction& tx,int32\_t v)
*   bool FaucetExactAmounts(struct CCcontract\_info *cp,Eval* eval,const CTransaction \&tx,int32\_t minage,uint64\_t txfee)
*   bool FaucetValidate(struct CCcontract\_info *cp,Eval* eval,const CTransaction \&tx)
*   int64\_t AddFaucetInputs(struct CCcontract\_infoCC\_info \*cp,CMutableTransaction \&mtx,CPubKey pk,int64\_t total,int32\_t maxinputs)
*   std::string FaucetGet(uint64\_t txfee)
*   std::string FaucetFund(uint64\_t txfee,int64\_t funds)
*   UniValue FaucetInfo()

Functions in `rpcwallet` implement:

`faucetaddress` fully implemented in [rpcwallet.cpp](https://github.com/jl777/komodo/blob/jl777/src/wallet/rpcwallet.cpp)

`faucetfund` calls `FaucetFund`

`faucetget` calls `FaucetGet`

`faucetinfo` calls `FaucetInfo`

Now you might not be a programmer, but I hope you are able to understand the above sequence. user types in a cli call, `komodo-cli` processes it by calling the rpc function, which in turn calls the function inside [faucet.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/faucet.cpp)

No magic, just simple conversion of a user command line call that runs code inside the komodod. Both the `faucetfund` and `faucetget` create properly signed rawtransaction that is ready to be broadcast to the network using the standard `sendrawtransaction` rpc. It doesnt automatically do this to allow the GUI to have a confirmation step with all the details before doing an irrevocable CC contract transaction.

`faucetfund` allows anybody to add funds to the faucet
`faucetget` allows anybody to get 0.1 coins from the faucet as long as they dont violate the rules.

And we come to what it is all about. The rules of the faucet. Initially it was much less strict and that allowed it to be drained slowly, but automatically and it prevented most from being able to use the faucet.

To make it much harder to leech, it was made so each `faucetget` returned only 0.1 coins (down from 1.0) so it was worth 90% less. It was also made so that it had to be to a fresh address with less than 3 transactions. Finally each txid was constrained to start and end with 00! This is a cool trick to force usage of precious CPU time (20 to 60 seconds depending on system) to generate a valid txid. Like PoW mining for the txid and I expect other CC contracts to use a similar mechanism if they want to rate limit usage.

Combined, it became such a pain to get 0.1 coins, the faucet leeching problem was solved. It might not seem like too much trouble to change an address to get another 0.1 coins, but the way things are setup you need to launch the `komodod` `-pubkey=<your pubkey>` to change the pubkey that is active for a node. That means to change the pubkey being used, the komodod needs to be restarted and this creates a lot of issues for any automation trying to do this. Combined with the PoW required, only when 0.1 coins becomes worth a significant effort will faucet leeching return. In that case, the PoW requirement can be increased and coin amount decreased, likely with a faucet2 CC contract as I dont expect many such variations to be needed.
export const title = "Chapter 07 - Rewards Example";
export const description = "Explore the Rewards example, a CC contract that allows users to lock funds for a specific period and earn extra rewards based on customizable parameters.";

# Chapter 07 - Rewards Example

The next CC contract in complexity is the rewards CC contract. This is designed to capture what most people like about masternodes, without anything else, ie. the rewards!

The idea is to allow people to lock funds for some amount of time and get an extra reward. We also want to support having more than one rewards plan at a time and to allow customization of plan details. One twist that makes it a bit unexpected is that anybody should be able to unlock the funds that were locked, as long as it ends up in the locking address. The reason for this is that SPV servers want to be supported and while locking can be done via normal `sendrawtransaction`, it requires a native node to do the unlocking. By allowing anybody to be able to unlock, then there can be a special node that unlocks all locked funds when they are ready. This way, from the user's point of view, they lock the funds and after it is matured, it reappears in their wallet.

The above requirements leads us to using the global CC address for the rewards contract to lock the funds in. That allows anybody to properly sign the unlock, but of course that is not enough, we need to make sure they are following all the unlock requirements. Primarily that the funds go back to the locking address.

The four aspects of the rewards plan that are customizable are:
`APR`, `minseconds`, `maxseconds`, `mindeposit`

This allows each plan to set a different APR (up to 25%, anything above is becoming silly), the minimum time funds must be locked, the maximum time they are earning rewards and the minimum that can be deposited.

So the `tx` that creates the rewards plan will have these attributes and it is put into the `OP_RETURN` data. All the other calls will reference the plan creation `txid` and inherit these parameters from the creation `tx`. This means it is an important validation to do, to make sure the funding `txid` is a valid funding `txid`.

Since it is possible that the initial funding will be used up, there needs to be a way for more funding to be added to the rewards plan.

Having multiple possible rewards plans means it is useful to have rpc calls to get information about them. Hence: `rewardslist` returns the list of rewards creation `txids` and `rewardsinfo <txid>` returns the details about a specific rewards plan.

A locking transaction sends funds to the rewards CC address, along with a normal (small) `tx` to the address that the unlock should go to. This allows the validation of the proper unlocking. Also, it is important to make sure only locking transactions are able to be unlocked. Additionally, the minimum time needs to elapse before unlocking is allowed.

All of these things are done in [rewards.cpp](https://github.com/jl777/komodo/blob/jl777/src/cc/rewards.cpp), with the validation code being about 200 lines and a total of 700 lines or so. Bigger than faucet, but most of the code is the non-consensus code to create the proper transactions. In order to simplify the validation, specific vin and vout positions are designated to have specific required values:

## createfunding

```bash
vins.*: normal inputs
vout.0: CC vout for funding
vout.1: normal marker vout for easy searching
vout.2: normal change
vout.n-1: opreturn 'F' sbits APR minseconds maxseconds mindeposit
```

## addfunding

```bash
vins.*: normal inputs
vout.0: CC vout for funding
vout.1: normal change
vout.n-1: opreturn 'A' sbits fundingtxid
```

## lock

```bash
vins.\*: normal inputs
vout.0: CC vout for locked funds
vout.1: normal output to unlock address
vout.2: change
vout.n-1: opreturn 'L' sbits fundingtxid
```

## unlock

```bash
vin.0: locked funds CC vout.0 from lock
vin.1+: funding CC vout.0 from 'F' and 'A' and 'U'
vout.0: funding CC change
vout.1: normal output to unlock address
vout.n-1: opreturn 'U' sbits fundingtxid
```

It is recommended to create such a vin/vout allocation for each CC contract to make sure that the rpc calls that create the transaction and the validation code have a specific set of constraints that can be checked for.
export const title = "Chapter 08 - Assets Example";
export const description = "Discover the Assets example, a CC contract that enables the creation and trading of tokens on a decentralized exchange (DEX) using colored coins.";

# Chapter 08 - Assets Example

In some respects the assets CC is the most complex, it was actually the first one that I coded. It is however using a simple model, even for the DEX functions, so while it is quite involved, it does not have the challenge/response complexity of dice.

There are two major aspects to creating tokens. First is to create and track it, down to every specific satoshi. The second is solving how to implement DEX functions of trading assets.

The model used is "colored coins". This means that the token creating txid issues the assets as denoted by all the satoshis, so locking 1 COIN issues 100 million tokens. This multiplication will allow creation of plenty of assets. We want to preserve all the tokens created across all allowed operations. The way this is achieved is that all operations attaches the token creation `txid` in its `OP_RETURN`, along with the specified operation.

Ownership of tokens are represented by the colored satoshis in the CC address for the user's `pubkey`. This allows using the standard utxo system to automatically track ownership of the tokens. This automatic inheritance is one of the big advantages of utxo CC contracts that compensates for the slightly more work needed to implement a CC contract.

So now we have the standard CC addresss, list and info commands that provide the CC addresses, list of all tokens and info on specific tokens and the ability to create and transfer tokens. Any amount of tokens can be created from 1 to very large numbers and using standard `addressbalance`, `addressutxo` type of commands, the details of all assets owned can be determined for a specific pubkey.

Now we can solve the DEX part of the tokenization, which turns out to be much simpler than initially imagined. We start with bidding for a specific token. Funds for the `bid` are locked into the global CC address, along with the desired token and price. This creates a `bid` utxo that is able to be listed via an orderbook rpc call. To fill the `bid`, a specific `bid` utxo is spent with the appropriate number of assets and change and updated price for the unfilled amount. if the entire amount is filled, then it wont appear in the orderbook anymore.

`asks` work by locking assets along with the required price. Partial fills can be supported and the rpc calls can mask the utxo-ness of the funds/assets needed by automatically gathering the required amount of funds to fill the specific amount.

With calls to cancel the pending `bid` or `ask`, we get a complete set of rpc calls that can support a COIN-centric DEX.

In the future, it is expected that a token swap rpc can be supported to allow directly swapping one token for another, but at first it is expected that there wont be sufficient volumes for such token to token swaps, so it was left out of the initial implementation.

With just these rpc calls and associated validation, we get the ability to issue tokens and trade them on a DEX!

## create

```bash
vin.0: normal input
vout.0: issuance assetoshis to CC
vout.1: tag sent to normal address of AssetsCCaddress
vout.2: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['c'] [origpubkey] "<assetname>" "<description>"
```

## transfer

```bash
vin.0: normal input
vin.1 .. vin.n-1: valid CC outputs
vout.0 to n-2: assetoshis output to CC
vout.n-2: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['t'] [assetid]
```

## buyoffer

```bash
vins.*: normal inputs (bid + change)
vout.0: amount of bid to unspendable
vout.1: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['b'] [assetid] [amount of asset required] [origpubkey]
```

## cancelbuy

```bash
vin.0: normal input
vin.1: unspendable.(vout.0 from buyoffer) buyTx.vout[0]
vout.0: vin.1 value to original pubkey buyTx.vout[0].nValue -> [origpubkey]
vout.1: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['o'] [assetid]
```

## fillbuy

```bash
vin.0: normal input
vin.1: unspendable.(vout.0 from buyoffer) buyTx.vout[0]
vin.2+: valid CC output satisfies buyoffer (*tx.vin[2])->nValue
vout.0: remaining amount of bid to unspendable
vout.1: vin.1 value to signer of vin.2
vout.2: vin.2 assetoshis to original pubkey
vout.3: CC output for assetoshis change (if any)
vout.4: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['B'] [assetid] [remaining asset required] [origpubkey]
```

## selloffer

```bash
vin.0: normal input
vin.1+: valid CC output for sale
vout.0: vin.1 assetoshis output to CC to unspendable
vout.1: CC output for change (if any)
vout.2: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['s'] [assetid] [amount of native coin required] [origpubkey]
```

## cancel

```bash
vin.0: normal input
vin.1: unspendable.(vout.0 from exchange or selloffer) sellTx/exchangeTx.vout[0] inputTx
vout.0: vin.1 assetoshis to original pubkey CC sellTx/exchangeTx.vout[0].nValue -> [origpubkey]
vout.1: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['x'] [assetid]
```

## fillsell

```bash
vin.0: normal input
vin.1: unspendable.(vout.0 assetoshis from selloffer) sellTx.vout[0]
vin.2+: normal output that satisfies selloffer (*tx.vin[2])->nValue
vout.0: remaining assetoshis -> unspendable
vout.1: vin.1 assetoshis to signer of vin.2 sellTx.vout[0].nValue -> any
vout.2: vin.2 value to original pubkey [origpubkey]
vout.3: CC asset for change (if any)
vout.4: CC asset2 for change (if any) 'E' only
vout.5: normal output for change (if any)
vout.n-1: opreturn [EVAL_ASSETS] ['S'] [assetid] [amount of coin still required] [origpubkey]
```
export const title = "Chapter 09 - Dice Example";
export const description = "Explore the Dice example, a CC contract that demonstrates how to build a fair and random dice game with real-time response and a fallback timeout mechanism.";

# Chapter 09 - Dice Example

The dice CC contract is actually more complex in the sequences required than the assets/tokens CC. The reason is the need for realtime response by the dealer node, but also having a way to resolve bets if the dealer node is not online. The dice CC contract shows how to build in such a challenge/response mechanism, which likely will be very useful for many other realtime interactive CC contracts.

First, let us describe the issues that the dice CC contract needs to solve. Foremost is that it needs to be random and fair. It should also have realtime response and a fallback timeout in case the realtime response doesnt happen. As with the rewards CC contract, multiple dice plans are supported. Each plan can be customized as to the following: `minbet`, `maxbet`, `maxodds`, `timeoutblocks`

This allows each plan to control the risk exposure and also advertises to everyone when dicebets expire and a timeout win can be claimed. In event the dealer node does not process a dicebet in time, in order to prevent dealer nodes from simply not responding to dicebets that they lose, a timeout must go to the dicebet player. A short timeframe means that the dealer would need to be running multiple redundant nodes to make sure they can respond in time. If the timeout is set to long, then many players would prefer to use a different dice plan with a shorter timeout.

Now to describe how to ensure a proper random number that is fair. The method chosen was for the dealer node to create transactions with hash of their entropy in the `OP_RETURN`. Then the dicebet player would select a specific entropy tx and include their (unhashed) entropy to their `OP_RETURN`. This allows the dealer node to immediately determine if the dicebet won or lost. If the dicebet included the hash of the bettor entropy, then another step would be needed. However, doing so would allow some timeouts to end with a refund, rather than an automatic win for the dicebet player.

One additional technique used to keep all required data on the blockchain is the dealer entropy value calculation. The vin0 txid is used as one of the `privkeys` to calculate a shared secret and then hashed to remove links to the original `privkey`. This method allows recreating the dealer's entropy value (by the dealer node) given the blockchain itself, which means there is no need for any local storage.

This allows the dealer node to recreate the unhashed entropy value used and so when the dicebet transaction is seen (in the mempool!), the dealer node can immediately determine if it is a winner or a loser. This is done by creating a dealer hash vs. a bettor hash via:

```bash
dealer hash: SHA256(dealer entropy + bettor entropy)
bettor hash: SHA256(bettor entropy + dealer entropy)
```

The same values are used, but in different order. The resulting hashes are compared arithmetically for 1:1 bets and the standard industry use is used for the higher odds: [https://dicesites.com/provably-fair](https://dicesites.com/provably-fair)

The dealer creates a dice plan and then also needs to create entropy transactions. Each win or loss that creates change also creates entropy transactions by the dealer, but timeout transactions wont as it needs to be created by the dealer node to prevent cheating. The dealer `tx` are locked into the global dice CC address, as is the dicebet transaction, which selects a specific entropy `tx` to "roll" against. Then the dicefinish process by the dealer will spend the dicebet outputs either all to itself for a loss, or the winning amount to th dice bettor's address. For dicebets that are not dicefinish'ed by the dealer, anybody is able to do a timeout completion.

## createfunding

```bash
vins.*: normal inputs
vout.0: CC vout for funding
vout.1: owner vout
vout.2: dice marker address vout for easy searching
vout.3: normal change
vout.n-1: opreturn 'F' sbits minbet maxbet maxodds timeoutblocks
```

## addfunding (entropy)

```bash
vins.*: normal inputs
vout.0: CC vout for locked entropy funds
vout.1: tag to owner address for entropy funds
vout.2: normal change
vout.n-1: opreturn 'E' sbits fundingtxid hentropy
```

## bet

```bash
vin.0: entropy txid from house (must validate vin0 of 'E')
vins.1+: normal inputs
vout.0: CC vout for locked entropy
vout.1: CC vout for locked bet
vout.2: tag for bettor's address (txfee + odds)
vout.3: change
vout.n-1: opreturn 'B' sbits fundingtxid entropy
```

## loser

```bash
vin.0: normal input
vin.1: betTx CC vout.0 entropy from bet
vin.2: betTx CC vout.1 bet amount from bet
vin.3+: funding CC vout.0 from 'F', 'E', 'W', 'L' or 'T'
vout.0: funding CC to entropy owner
vout.1: tag to owner address for entropy funds
vout.2: change to fundingpk
vout.n-1: opreturn 'L' sbits fundingtxid hentropy proof
```

## winner

```bash
same as loser, but vout.2 is winnings
vout.3: change to fundingpk
vout.n-1: opreturn 'W' sbits fundingtxid hentropy proof
```

## timeout

```bash
same as winner, just without hentropy or proof
```

There is an attack vector that precludes betting any large amounts, it goes as follows:

*   Do dicebet to get the house entropy revealed
*   Calculate bettor entropy that would win against the house entropy
*   Reorg the chain and make a big bet using the winning entropy calculated in 2.

In order to mitigate this, the disclosure of the house entropy needs to be delayed beyond a reasonable reorg depth (notarization). It is recommended for production dice games with significant amounts of money to use such a delayed disclosure method.
export const title = "Chapter 10 - Channels Example";
export const description = "Learn about the Channels example, a powerful CC contract that enables instant payments secured by dPoW, offering security, low cost, and backward compatibility.";

# Chapter 10 - Channels Example

It might be hard to believe, but channels CC implements an instant payment mechanism that is secured by dPoW in a way that is backward compatible with the existing wallets, explorers, etc. and channels CC does not require both nodes to be online. Its usecases are all the usecases for Lightning Network, it is just more secure, less expensive and backward compatible! The one aspect which some might consider a downside (and others another benefit) is that all payments are onchain. This means it would increase blockchain size, but the idea is for channels CC to be used on blockchains with relatively lower value coins, so a txfee of 0.0001 is not anything significant.

Very confusing blockchain reorganization issues described below. Will be confusing to most people

From a distance, the blockchain is a chain of blocks. One block after the next, each referencing all the prior blocks. Each block containing a group of transactions. Prior to getting into a block, the transactions are broadcast to the network and if it is valid, it enters the memory pool. Each miner then constructs a valid block from these memory pool transactions and when a transaction gets mined (confirmed), it is removed from the memory pool.

That is the simple version!

The reality is quite a bit more complex, but the critical aspect is that the blockchain can (and is) reorganized as part of the expected protocol. This can happen even when there is no 51% attack happening and it is important to understand this process in detail, so here goes.

What happens if two miners find a valid block at the same time? In this case the "same time" means within the time it takes for a block to propagate to the network. When a miner finds a new block, it is broadcast to the network and nodes update and start waiting for the next block. When there are two different (and valid) blocks propagating at the same time, some nodes update with one of the blocks and some the other, lets call it blockA and blockB. Now the nodes will know about both blockA and blockB, but some will consider blockA to be the chaintip and others will consider blockB to be the chaintip.

This is where it gets confusing. Which is the correct chaintip (latest block?). It turns out that both blockA and blockB are valid at this moment in time. So there are actuall two blockchains. We have what is called a small fork! Now dont worry, the protocol will help us converge to a single chain, but in order to do that, we need the next block.

Some miners will be mining from blockA and others from blockB. In most all cases, when the next block is found, it wont be at the "same time" again. So we will end up with a chain that is blockA+blockA2 or blockB+blockB2. Here comes the small reorg! Let's assuming blockA2 was found before blockB2, so that means all nodes that had blockB as the chaintip now see a longer chain blockA+blockA2, which trumps blockB. When that happens, it reorgs the chain so it is on blockA+blockA2. To do this properly, all the transactions that were in blockB are put back into the mempool and blockA is added, then blockA2.

Of course, when blockB2 arrives, the nodes see it but blockB+blockB2 is the same length as blockA+blockA2, so no reorg happens. Since we postulated that blockAs arrived "before" blockB2, that means all nodes are on the same chaintip, including all the miners and the next block found would be blockA3, without any complications.

Believe it or not, this sort of thing is happening all the time, one all blockchains. The chaintip is a volatile thing and that is why more than one confirmation is needed to avoid the small reorgs invalidating blockhash. However, it is possible for more than just the blockhash to change. When the reorg happens, all the transactions in the block are put back into the mempool and then the new blocks are processed in order. So what happens if one of the inputs to a transaction that happened in blockB, gets spent in blockA2? Based on random utxo allocation by wallets this is not impossible if an address has a lot of activity, but if it is part of a 51% attack, then this remote chance of an utxo being spent becomes a certainity! In fact, that is what a 51% attack is.

The attack can go much deeper than just one block. For chains that use the longest chain rule, it can go quite deep indeed. So as all the reorged transactions are put back into the mempool, we feel good that it will get confirmed again. Unfortunately, there is no enforcement of a miner needing to mine any specific transaction in the mempool. And the 51% attacker is intent on mining the transaction that spends an already spent utxo in the reorganized chain. it is called a double spend, but in the reorganized chain, it is spent only once. So it is a bit of a misnomer.

The important thing to understand is that if any transaction has inputs that are signed by a node, it is possible when the chain reorganizes for that transaction to become invalid. This is why dPoW is important as it doesnt strictly use the longest chain rule, but rather the longest notarized chain rule. Once a block is notarized, then it will refuse to reorganize that block (or any block before). So the risk is still there, but only until a notarization. Please see more detailed information about dPoW `here`.

Given the above, if you are wondering how can it be possible to have a mempool payment be secured by dPoW. Since it is explained how the reorgs can make valid transactions disappear, it seems unlikely any such solution is possible. However, the CC is very powerful and it can make unlikely things possible.

The following describes how.

We know that any payment that is utxo based can be invalidated via 51% attack, or even an unlikely but not impossible random utxo allocation from a busy wallet. Which means the payment cant be via a utxo. Since the CC system is utxo based, you might think that it means CC cant solve this. However, CC is very powerful and can implement payments that are not utxo based. But before this non-utxo payment method is explained, first we need to solve the mechanics of payment.

At a high level, we want to lock funds into a channel, have this lock notarized so it cant be reorganized. Then payments can unlock funds. Additionally, if we are restricting the payment to just one destination, we also need a way for the sender to reclaim the unused funds. So there needs a way for a close channel notification, which when notarized allows the sender to reclaim all funds. After the channel close is notarized, then the only action possible should be a reclaim of sender funds.

We need to assume that any payment, channel close, reclaim can be reorganized until it is notarized so great care needs to be made that a payment that is made will always be valid. With some allowances for blocks after a channelclose is notarized, we can protect the payments using the logic of "stop accepting payments after a channelclose is seen". It might be that a full notarization of wait time after the channelclose is notarized is needed to provide sufficient time for all the payments to be reprocessed.

Now we can finally describe the requirements for the CC. The locked funds need to be able to be spent by either the sender or receiver, the former only after sufficient time after a channelclose and the latter only after a payment is seen (not just confirmed, but just seeing it should be enough). The protection from reorgs is that the payment itself reveals a secret that is needed for the payment and only the secret would be needed, so it wont matter what utxo is used. To lock funds into a CC address that can handle this we need a 1of2 CC address, which can accept a signature from either of two pubkeys. The additional CC constraints would be enforced to make sure payments are made until the channel is closed.

A hashchain has the nice property of being able to encode a lot of secrets with a single hash. You can hash the hash, over and over and the final hash is the public value. By revealing the next to last hash, it can be verified that it hashes to the final hash. There is a restriction that a hashchain needs to be of reasonable maximum depth, say 1000. That means each iteration of the hashchain that is revealed is worth 1/1000th the total channelfunds. In fact, if the 500th hash value is revealed, half the channelfunds are released. this allows 1/1000th resolution that can be released with a single hash value.

Now we can make the payment based on the hashvalue revealed at a specified depth before the prior released hashchain value. Both the sender and receiver can make a payment to the destination by attaching a hashchain secret. This means even if the sender's payment is reorganized, if the destination has the revealed secret, a replacement payment can be made that is valid. If the destination account isnt monitoring the blockchain, then it wont see the revealed secret, but in this case there shouldnt be value released for the payments that are reorganized. So it would be a case of no harm, no foul. In any event, all the payments end up verifiable on the blockchain to provide verifiability.

Payments at the speed of the mempool, protected by dPoW!

## The following are the rpc calls:

```bash
channelsopen
channelspayment
channelsclose
channelsrefund
channelsinfo
```

### channelsopen:

Used to open channel between two pub keys (sender and receiver). Parameters: `destination_pubkey`, `total_number_of_payments`, `payment_denomination`.

```bash
Example - channelsopen 03a8fe537de2ace0d9c210b0ff945085c9192c9abf56ea22f22ce7998f289bb7bb 10 10000000
```

### channelspayment:

Sending payment to receiver. Condition is that the channel open tx is confirmed/notarised. Parameters: `open_tx_id`, `payment_amount`, `[secret]` (optional, used when receiver needs to make a payment which secret has already been revealed by sender).

```bash
Example - channelspayment b9c141facc8cb71306d0de8e525b3de1450e93e17fc8799c8fda5ed52fd14440 20000000
```

### channelsclose:

Marking channel as closed. This RPC only creates a tx which says that the channel is closed and will be used in refund RPC to withdraw funds from closed channel. This also notifies receiver that channel fund could be withdrawn, but the payment RPC is still available until all funds are withdrawn. Parameters: `open_tx_id`.

```bash
Example - channelsclose b9c141facc8cb71306d0de8e525b3de1450e93e17fc8799c8fda5ed52fd14440
```

### channelsrefund:

Withdrawing funds back to senders address. Refund can be issued only when channel close tx is confirmed/notarised. Parameters: `open_tx_id`, `close_tx_id`

```bash
Example - channelsrefund b9c141facc8cb71306d0de8e525b3de1450e93e17fc8799c8fda5ed52fd14440 bb0ea34f846247642684c7c541c435b06ee79e47893640e5d2e51023841677fd
```

### channelsinfo:

Getting info about channels in which the issuer is involved, either as sender or receiver. Call without parameters give the list of available channels. Parameters: `[open_tx_id]` (optional - used to get info about specific channel)

## VIN/VOUT allocation

### Open:

```bash
vin.0: normal input
vout.0: CC vout for channel funding on CC1of2 pubkey
vout.1: CC vout marker to senders pubKey
vout.2: CC vout marker to receiver pubkey
vout.n-2: normal change
vout.n-1: opreturn - 'O' zerotxid senderspubkey receiverspubkey totalnumberofpayments paymentamount hashchain
```

### Payment:

```bash
vin.0: normal input
vin.1: CC input from channel funding
vin.2: CC input from src marker
vout.0: CC vout change to channel funding on CC1of2 pubkey
vout.1: CC vout marker to senders pubKey
vout.2: CC vout marker to receiver pubkey
vout.3: normal output of payment amount to receiver pubkey
vout.n-2: normal change
vout.n-1: opreturn - 'P' opentxid senderspubkey receiverspubkey depth numpayments secret
```

### Close:

```bash
 vin.0: normal input
 vin.1: CC input from channel funding
 vin.2: CC input from src marker
 vout.0: CC vout for channel funding
 vout.1: CC vout marker to senders pubKey
 vout.2: CC vout marker to receiver pubkey
 vout.n-2: normal change
 vout.n-1: opreturn - 'C' opentxid senderspubkey receiverspubkey 0 0 0
```

### Refund:

```bash
vin.0: normal input
vin.1: CC input from channel funding
vin.2: CC input from src marker
vout.0: CC vout marker to senders pubKey
vout.1: CC vout marker to receiver pubKey
vout.2: normal output of CC input to senders pubkey
vout.n-2: normal change
vout.n-1: opreturn - 'R' opentxid senderspubkey receiverspubkey numpayments payment closetxid
```
export const title = "Chapter 11 - Oracles Example";
export const description = "Discover the Oracles CC, a powerful and efficient method to bring external data onto the blockchain, enabling data markets and financial incentives.";

# Chapter 11 - Oracles Example

[Oracles CC](https://github.com/jl777/komodo/blob/jl777/src/cc/oracles.cpp) is an example where it ended up being simpler than I first expected, but at the same time a lot more powerful. It is one of the smaller CC, but it enables creation of an arbitrary number of data markets, in a performant way.

In order to gain the performance, some clever usage of special addresses was needed. It was a bit tricky to generate a special address to keep track of the latest data.

Let's back up to the beginning. Just what is an oracle? In this context it is something that puts data that is not on the blockchain, onto the blockchain. Since everything other than the transactions and blocks are not in the blockchain, there is a very large universe of data that can be oracle-ized. It can be literally anything, from the obvious like prices to specific results relative to an arbitrary description.

The most difficult issue about oracles is that they need to be trusted to various degree to provide accurate and timely data. The danger is that if a trusted node is used to write data to the blockchain, it creates a trust point and a single point of attack. Ultimately there is nothing that can ensure only valid data is written to the blockchain, so what is done is to reinforce good behavior via pay per datapoint. However, for critical data, higher level processing is needed that combines multiple data providers into a validated signal.

At the oracles CC level, it is enough that there is financial incentive to provide good data. Also it is needed to allow multiple vendors for each data that is required and to enable efficient ways to update and query the data.

## The following are the rpc calls:

```bash
oraclescreate name description format
oracleslist
oraclesinfo oracletxid
oraclesregister oracletxid datafee
oraclessubscribe oracletxid publisher amount
oraclesdata oracletxid hexstr
oraclessamples oracletxid batonutxo num
```

The first step is to create a specific data description with `oraclescreate`, which also defines the format of the binary data. This creates an oracletxid, which is used in the other rpc calls. `name` and `description` are just arbitrary strings, with name preferably being a short name used to access the data. The format is a string comprised of a single character per data element:

```bash
's' -> <256 char string
'S' -> <65536 char string
'd' -> <256 binary data
'D' -> <65536 binary data
'c' -> 1 byte signed little endian number, 'C' unsigned
't' -> 2 byte signed little endian number, 'T' unsigned
'i' -> 4 byte signed little endian number, 'I' unsigned
'l' -> 8 byte signed little endian number, 'L' unsigned
'h' -> 32 byte hash
```

For example, if the datapoint is comprised of a `4byte` timestamp and an `8byte` number the format string would be: `"IL"`

`oracleslist` displays a list of all the `oraclestxid` and `oraclesinfo` displays information about the specific `oracletxid`. Each `oracletxid` deterministically generates a marker address and a small amount is sent to that address to mark a transaction's relation to the `oracltxid`.

```json
{
  "result": "success",
  "txid": "4895f631316a649e216153aee7a574bd281686265dc4e8d37597f72353facac3",
  "name": "BTCUSD",
  "description": "coindeskpricedata",
  "format": "L",
  "marker": "RVqJCSrdBm1gYJZS1h7dgtHioA5TEYzNRk",
  "registered": [
    {
      "publisher": "02ebc786cb83de8dc3922ab83c21f3f8a2f3216940c3bf9da43ce39e2a3a882c92",
      "baton": "RKY4zmHJZ5mNtf6tfKE5VMsKoV71Euej3i",
      "batontxid": "4de10b01242ce1a5e29d5fbb03098b4519976879e05ad0458ef7174ed9127f18",
      "lifetime": "1.50000000",
      "funds": "0.01000000",
      "datafee": "0.01000000"
    }
  ]
}
```

A `data publisher` needs to register a `datafee` and their `pubkey` for a specific `oracletxid`. `datafee` needs to be at least as big as a `txfee`. Using `oraclesregister` the current `datafee` can be updated so a `publisher` can adapt to market conditions. Once registered, subscribers can prepay for some number of datapoints to a specific `publisher` using the `oraclessubscribe` rpc. At first, it is likely that the `publisher` would pay themselves to enable the posting of initial data points so the potential subscribers can evaluate the quality and consistency of the data.

The one final rpc is `oraclessamples`, which returns the most recent samples of data from a specific `publisher`. In order to have a performant solution to track all the potential data streams from all the publishers for all the `oracletxid`, a baton `utxo` is used. This is an output sent to a specific address and expected to have just a single `utxo` at any given time to allow for direct lookup. `oraclessamples` requires a starting `txid` to use and with each datapoint having the prior `batontxid`, there is a reverse linked list to traverse the most recent data.

## VIN/VOUT allocation

In order to implement this, the following vin/vout contraints are used:

### create

```bash
vins.*: normal inputs
vout.0: txfee tag to oracle normal address
vout.1: change, if any
vout.n-1: opreturn with name and description and format for data
```

### register

```bash
vins.*: normal inputs
vout.0: txfee tag to normal marker address
vout.1: baton CC utxo
vout.2: change, if any
vout.n-1: opreturn with oracletxid, pubkey and price per data point
```

### subscribe

```bash
vins.*: normal inputs
vout.0: subscription fee to publishers CC address
vout.1: change, if any
vout.n-1: opreturn with oracletxid, registered provider's pubkey, amount
```

### data

```bash
vin.0: normal input
vin.1: baton CC utxo (most of the time)
vin.2+: subscription or data vout.0
vout.0: change to publishers CC address
vout.1: baton CC utxo
vout.2: payment for dataprovider
vout.3: change, if any
vout.n-1: opreturn with oracletxid, prevbatontxid and data in proper format
```

The `oraclesdata` transaction is the most complex as it needs to find and spend the baton `utxo`, use the correct `datafee` and spend funds from the locked subscription funds. With the above, the oracles CC is complete and allows the creations of massively parallel data streams from multiple vendors that uses free market feedback via payments, ie. poorly performing providers wont get renewals.

I expect that at first, the data providers will just be dapp developers deploying a working system including the required data, but its structure allows open market competition. Of course, specific dapps could restrict themselves to using only publishers from a whitelist of pubkeys. The potential usecases for oracles CC is quite varied and limited only by the imagination.
export const title = "Chapter 12 - Limitless Possibilities";
export const description = "Unleash the limitless possibilities of utxo-based smart contracts, offering security, scalability, and a foundation for innovative CC contracts.";

# Chapter 12 - Limitless Possibilities

As can be seen, CC contracts can do a wide range of things and since they are Turing complete, we know that this is true. However, what is more important is the added security gained from using a utxo based system. While in some ways it is more complex to have to deal with utxo, as can be seen by the above examples, it is either solved and made invisible at the rpc level, or actually used as part of the solution.

Being utxo based, automatically builds in a rate limit to how many tx per block a specific CC contract can do. The state advancing by one transaction at a time is another means that rate limits. Since more utxo can be made available to increase capacity, it actually offers a way for managing load.

I believe I have made one of the first operational utxo smart contracts, CC or otherwise and hope that there will be many more developers joining forces to create more foundational CC contracts. Feel free to contact me for feedback on the type of CC contract you want to make. I have not documented all my notes and it could well be I already sort of know how to implement what your want your CC contract to do. Just only so many I can actually make time to code and debug.

Our testing cycle went a lot faster than expected as the bugs found were few and far between. Considering the scope of the assets CC and the realtime response aspects of dice CC, this was quite unexpected. I can only attribute it to the fact that CC validation is just the final validation on top of all the standard bitcoin protocol validations. Not having to worry about double spends is sure a nice luxury, though dont get too complacent about chain rewrites! It is possible to wait for information to be divulged and then reorg the chain to take advantage of this knowledge in a chain which is rewound.

Yes, blockchains are complicated.
export const title = "Chapter 13 - Different Languages";
export const description = "The current smart contracts are in C/C++, but any other languages that can create linkable libraries that can be called C/C++ functions can be used.";

# Chapter 13 - Different Languages

The current codebase is integrated into the komodod codebase, which is C/C++. However, it is possible to use different languages and integrate into the C/C++ as zcash has shown by using the rust language for some parts of the `zcashd`.

I think any language that is compiled and can create a linkable library while being able to call and be called by C/C++ functions can be used. If you are able to make such a language binding for a simple CC contract like faucet, this will be good for a 777 KMD bounty. Of course, you need to be the first to submit a properly working pull request.
export const title = "Chapter 14 - Runtime Bindings";
export const description = "Unlock the potential of runtime bindings for dynamic linking of CC contract plugins, fostering a vibrant blockchain ecosystem.";

# Chapter 14 - Runtime Bindings

Once build time linking works, then it is one step away from being able to do runtime linking, ie. dynamically linked libraries. There will be some work required to prevent duplication of eval codes and making sure it is a valid version of the CC contract plugin, but these are issues that have been solved before and I dont see any reason they cant be solved for CC contracts.

This would open up the door for quite an interesting ecosystem of CC plugins that blockchains can subscribe to.
export const title = "Chapter 15 - RPC based dAPPS";
export const description = "If enough CC contracts with their RPC methods are integrated, then most new dAPPS can be created using just the RPC methods without creating new CC contracts.";

# Chapter 15 - RPC based dAPPS

Ultimately, I expect there to be so many new rpc calls (one set from each CC contract), that virtually any dapp can be made with rpc calls. We are just at the beginning now, but it is just a matter of time when we get there.

For now, we just need to keep listening to what the market wants as far as dapps go. Then make a new CC contract that enables doing as many of those as possible.

Repeat...

Imagine the scope that will exist after a year or two of continuous new CC contracts being created, along with all the rpc based dapps. I have seen some automatic GUI generators and it could be that for most cases, there can be a special GUI that not only create the dapp's GUI, but also all the rpc calls that are needed to make it work the way it is customized.

This codebase and tools in between the GUI and the rpc level will be a very good area for new initiatives.
export const title = "Frequently Asked Questions";
export const description = "Find some frequency asked questions about CC contracts in this page.";

# Frequently Asked Questions

**Q: Can I code my own smart contract in Go language and compile it to a library file (example .a file), and use that to compile with komodo source code?**

A: As long as it compiles to a linkable library, the language for the new contract (faucet.cpp equivalent) won't matter. It would just need to be compatible with the C/C++ stack calling convention. It is `komodod` that is doing all this. So, it just seems logical to extend `komodod`. It is a native contract, directly accessing the DB and datastructures.

**Q: What exactly is the purpose of these addresses that are in the source code, with privkeys? I just imported RFYE2yL3KknWdHK6uNhvWacYsCUtwzjY3u on a test chain ATEST and spent the .0001 that was in it.**

A: You can only spend the normal funds in those addresses, CC outputs are protected. CC addresses map the CC scriptPubKey to an address, not the pubkey. The purpose of the addresses are to have special addresses that all nodes have the privkey for and are able to sign the CC transaction to release otherwise locked funds. i.e., there are only a limited number of ways the funds in a CC output can be spent (all these are what makes up the code of the contract) and all of them are valid so anyone on the network can sign an output when its unlock condition is satisfied.

**Q: what's the purpose of sending coins to these addresses that are in the source code?**

A: Depends on the CC contract

*   for the faucet contract, the purpose is to have funds for the faucet
*   for the assets contract, the purpose is to create colored coins
*   for the rewards contract, the purpose is to have funds for the rewards etc.,

Contracts usually needs to have funds to operate.

**Q: What is the importance of the EVAL codes like the ones in [jl777/komodo:src/cc/eval.h@jl777#L43](https://github.com/jl777/komodo/blob/jl777/src/cc/eval.h#L43) ?**

A: EVAL codes in eval.h are the CC contract-type ID. e.g. "rewards contract" ID is 0xe5, faucet contract is 0xe4. The goal is to have building blocks of smart contracts. The smart contract "library" or "catalogue" is available to all of komodo. You pick what you need to use for your use of blockchain. If you need something different, you pick the "smart contract of closest fit" and make your changes. If you want, you PR it upstream back to komodo and it is included in the komodo "catalogue of smart contracts".

**Q: Can you chain together contracts like IF statements?**

A: As of July 2018, the contracts currently use the absolute simplest possible CryptoConditions. With these, the developer is able to do assets, rewards, faucet and more. There is no reason we can't make a contract that knows about other contracts. If there is a description of what the contract does in terms of utxo, more than likely, it can be done.

**Q: What can a Komodo Smart Contract access on the blockchain?**

A: WIP I dont think any other bitcoin protocol blockchain has contracts code with full access to prior blockchain data.

**Q: Does each additional contract require a hard fork?**

A: Adding support for a new contract would require a hardfork. It also depends on what you mean, how it was deployed and if any specific CC contracts were done (i.e., some types of changes to existing contracts cause hard forks and others don't). There are plans to make an enable/disable mask for specific contracts. The best ways to deal with varied activations on the different chains are being discussed. We are also working on limited life contracts, so maybe things can be setup so they expire. That would avoid the need for hardforking to change an existing one. but if a chain wants to hardfork, it can and since it is independent, it wont affect other chains in the eco-system. Isolation of code is a time tested method of limiting damage from bugs

**Q: How do CyptoConditions help in decision making contracts based on real world events?**

A: You could write a custom eval function that queries oracles and controls behavior based on that. The custom functions are part of the consensus rules as all nodes need to validate the outcomes. Writing consensus code is not for weekend coders, that only leads to trouble. We are making working templates and then allow people to tweak the parameters and not have to do the actual coding. even that is pretty dangerous. Remember that each custom eval function is embedded in a specific independent chain, being an independent chain it is independent of all the other chains. So it can destroy itself and no other chain would even know, except if you were doing atomic swaps with that chain, that is the only impact. Code isolation is key. Having a system that allows anybody to deploy code that affects everybody is pretty brave (or insane). All the chains in a cluster might be running the same contracts, so a bug in any one of them is a bug in all of them anyway or It is possible to run a different set of contracts on different chains in the cluster. So at scale there might be interaction issues if care is not taken to standardise some of the core contracts.

**Q: If CryptoConditions is language agnostic, what stops someone from making an infinite loop? or some other code that might damage the node/network/blockchain?**

A: It is a native contract running at native speeds. Just like nothing prevents someone from writing an infinite loop in the coin daemon's source code, there is nothing preventing someone from writing malicious/buggy contracts. But the people running the code are responsible for either checking the code themselves if they have the capacity or have it checked by someone they trust. (i.e., just the usual OpenSource style). There will be some core contracts that are part of the KMD source code that are useful for any asset that is created. Ex: faucets, On-chain exchanges, Rewards based on locking funds for some time to name a few. For any more specific/custom contracts anyone is welcome to fork the codebase and write their own contracts that will run on their own blockchain. If a contract that is written downstream is deemed more-efficient/useful then it can be merged into the main codebase.

**Q: Are there any resources to help me understand more about this?**

A: If you have familiarity with programming and have the patience, you can go through the comments in following files: [jl777/komodo:src/cc/assets.cpp@dev](https://github.com/jl777/komodo/blob/dev/src/cc/assets.cpp) and in the directory [jl777/komodo:src/cc/@dev](https://github.com/jl777/komodo/tree/dev/src/cc) , start with faucet, then rewards then assets.

CC are a new type of vout using the bitcoin protocol utxo system. The CC contract code adds constraints on the existing vins and vouts and allows us to add rules and describe circumstances where specific utxos can be spent/claimed or remain locked. This can be thought of as an extension of the CLTV and multisig functionality already available in Bitcoin but much more comprehensive and robust allowing for very complex contracts.

CC allows us to create colored utxo and a specific set of new rules that govern these colored utxos.

**Didn't find your answer here? Please ask your questions in the `#cc-general` channel in** [Komodo Discord](https://komodoplatform.com/discord)
export const title = "How to write UTXO based CC modules for KMD based chains";
export const description = "Learn how to write UTXO-based CC modules for Smart chains with this comprehensive guide by jl777, enabling secure and powerful smart contracts.";

# How to write UTXO based CC modules for KMD based chains - by jl777

A non-technical introduction: [https://komodoplatform.com/en/blog/crypto-conditions-utxo-based-smart-contracts/](https://komodoplatform.com/en/blog/crypto-conditions-utxo-based-smart-contracts/)

Source text: [jl777/komodo:src/cc/CC%20made%20easy@FSM](https://github.com/jl777/komodo/blob/FSM/src/cc/CC%20made%20easy.md)

## Introduction

This is not the only smart contracts methodology that is possible to build on top of `OP_CHECKCRYPTOCONDITION`, just the first one. All the credit for getting `OP_CHECKCRYPTOCONDITION` working in the Komodo codebase goes to [@libscott](https://github.com/libscott). I am just hooking into the code that he made and tried to make it just a little easier to make new contracts.

There is probably some fancy marketing name to use, but for now, I will just call it "CC contract" for short, knowing that it is not 100% technically accurate as the CryptoConditions aspect is not really the main attribute. However, the KMD contracts were built to make the CryptoConditions codebase that was integrated into it to be more accessible.

Since CC contracts run native C/C++ code, it is turing complete and that means that any contract that is possible to do on any other platform will be possible to create via CC contract.

UTXO based contracts are a bit harder to start writing than for balance based contracts. However, they are much more secure as they leverage the existing bitcoin utxo system. That makes it much harder to have bugs that issue a zillion new coins from a bug, since all the CC contract operations needs to also obey the existing bitcoin utxo protocol.

This document will be heavily example based so it will utilize many of the existing reference CC contracts. After understanding this document, you should be in a good position to start creating either a new CC contract to be integrated into komodod or to make rpc based dapps directly.

I hope this document will help you understand what a Komodo utxo based CC contract is and how it is different from the other smart contracts. If you are able to dive into the [cc directory](https://github.com/jl777/komodo/tree/FSM/src/cc/) and start making your own CC contract after reading this document, then I am very happy!

This section contains the following docs:
export const title = "Historical Documentation"
export const description = "This section contains content that is interesting historically and may not have much necessity to be perused at this time."

# Historical Documentation

This section of the documentation contains content that is interesting historically and may not have much necessity to be perused at this time.
export const title = "Whitepaper: Chapter-1";
export const description = "Explore the foundations of blockchain security, including PoW and the Double Spend problem, and discover how Komodo's dPoW technology enhances security.";

# A Foundational Discussion of Blockchain Security

Komodo’s form of providing security is called Delayed Proof of Work technology
(dPoW). It builds on the most advanced form of blockchain security in existence,
Proof of Work technology (PoW). The latter form of security is the method that the
Bitcoin network utilizes. To understand the value of Komodo’s dPoW security, we
must first explain how PoW works and why it is the most secure method of maintaining a decentralized blockchain. We must also examine PoW’s shortcomings, so
that we may understand the need for Komodo’s dPoW method and the advantages
it provides to the blockchain community.

To understand how PoW technology functions, we begin by explaining the roots
that make the Bitcoin protocol a viable means of securely transferring value.

## What Is A Consensus Mechanism?

### The "Double Spend" Problem

The creation of blockchain technology stems from the early mathematical studies
of encryption using computer technology.

One such example is related to the information-encoding device, "Enigma," invented by the Germans at the end of World War I. Alan Turing, a British Intelligence agent, famously beat the Enigma device by inventing the world’s first "digital computer." This provided enough computing power to break [Enigma’s](https://en.wikipedia.org/wiki/Enigma_machine) encryption and discover the German secret communications.

This early affair with encryption set off a race throughout the world to develop
myriad forms of securely transferring information from one party to another via
computer technology. While each new form of computer encryption provided more
advantages, there remained one problem that prevented encryption from being useful
as a means of transferring not just information, but also financial value.

This challenge is known as the "Double Spend" problem. The issue lies in the ability
of computers to endlessly duplicate information. In the case of financial value, there
are three important things to record: who owns a specific value; the time at which the person owns this value; the wallet address in which the value resides. When
transferring financial value from one person to another, it is essential that if Person A
sends money to Person B, Person A should not be able to duplicate the same money
and send it again to Person C.

The [Bitcoin protocol](https://en.wikipedia.org/wiki/Bitcoin_network), invented by an anonymous person (or persons) claiming the
name of Satoshi Nakamoto, solved the Double Spend problem. The underlying math
and computer code is both highly complex and innovative. For the purposes of this
paper we need only focus on the one aspect of the Bitcoin protocol that solves the
Double Spend problem: the consensus mechanism.

### The Consensus Mechanism Provides Security Against a "Double Spend"

The consensus mechanism created by Nakamoto is perhaps one of the most powerful innovations of the twenty-first century. His invention allows individual devices to
work together, using high levels of encryption, to securely and accurately track ownership of digital value (be it financial resources, digital eal estate, etc.). It performs
this in a manner that does not allow anyone on the same network (i.e. the Internet)
to spend the same value twice.

Let us suppose a user, Alice, indicates in her digital wallet that she wants to send
cryptocurrency money to a friend. Alice’s computer now gathers several pieces of
information, including any necessary permissions and passwords, the amount that
Alice wants to spend, and the receiving address of her friend’s wallet. All this information is gathered into a packet of data, called a "transaction," and Alice’s device
sends the transaction to the Internet.

There are several types of devices that will interact with Alice’s transaction on
the Internet. These devices will share the transaction information with other devices
supporting the cryptocurrency network. For this discussion, we need only focus on
one type of device: a cryptocurrency miner.

The following descriptions are simplified explanations of a truly complex byzantine process. There are many other strategies cryptocurrency miners devise to out-mine their competition, and those strategies can vary widely.

### A Miner Competes to Add Blocks to the Network’s History, in Exchange for a Reward

#### Step One: Preparing the Preliminary Information

This device is performing an activity called cryptocurrency "mining." Let us focus
now on a mining device that captures Alice’s raw transaction data. This device is
owned by a tech-savvy miner, named Bob, who wants to add Alice’s transaction to
the permanent history of the Bitcoin network.

If Bob is the first person to properly process Alice’s transaction he will receive a
financial reward. One key part of this reward is a percentage-based fee, taken from
Alice’s total transaction amount.

#### The Mempool is the Collection of All Raw Transactions Waiting to be Processed

Furthermore, Bob does not have just one transaction alone to mine. Rather, he has
an entire pool of raw transactions, created by many people across the Internet. The
raw data for each of these transactions sits in the local memory bank of each miner’s
mining device, awaiting the miner’s commands. Miners call this pool of transactions,
the "mempool." Most miners have automated systems to determine the transaction-
selection process, based on estimated profit.

#### Creating Transaction Hashes

After Bob makes his choices about which transactions he will attempt to mine (and
we assume that he includes Alice’s transaction), Bob’s mining device then begins a
series of calculations.

His device will first take each individual transaction’s raw data and use mathematical formulas to compress the transaction into a smaller, more manageable form. This
new form is called a "transaction hash." For instance, Alice’s transaction hash could
look like this:

```bash
b1fea52486ce0c62bb442b530a3f0132b826c74e473d1f2c220bfa78111c5082
```

Bob will prepare potentially hundreds of transaction hashes before proceeding to
the next step.One important thing to understand about the compression of data in
the Bitcoin protocol, including the transaction hash above, is that calculations herein
obey a principle called, The Cascade Effect.

#### The Cascade Effect: Changing One Bit of Data Changes the Entire Result

The Cascade Effect simply means that were Bob to attempt to change even the
smallest bit in the raw data—whether from a desire to cheat, or by mistake, or for
any other reason—the entire transaction hash would dramatically change. In this
way, the mathematical formulas in the Bitcoin protocol ensure that Bob cannot create
an improper history.

Were Bob to attempt to create an incorrect transaction hash, other miners on the
network could use the raw transaction data from Alice, perform the proper mathematical formulas in the Bitcoin protocol, and immediately discover that Bob’s hashes are
incorrect. Thus, all the devices on the network would reject Bob’s incorrect attempts
and prevent him from claiming rewards.

#### Step One Continued: Finishing the Preliminary Calculations

Now, using more mathematical formulas, Bob takes the transaction hashes he is
attempting to process and compresses them into a new manageable piece of data.

This is called, "the merkle root." It represents all the transactions that Bob hopes to
process, and from which he hopes to gain a reward. Bob’s merkle root could look like this:

```bash
7dac2c5666815c17a3b36427de37bb9d2e2c5ccec3f8633eb91a4205cb4c10ff
```

Finally, Bob will gather information provided from the last miner that successfully
added to the permanent blockchain history. This information is called, "the block
header." It contains a large amount of complex data, and we won’t go into all the
details. The one important element to note is that the block header gives Bob clues
about how to properly add the next piece of information to the permanent Bitcoin
history. One of these hints could look like this:

```bash
"difficulty" : 1.00000000
```

We will return to this clue further on.

Having all this information, Bob is nearly prepared. His next step is where the real challenge begins.

#### Step Two: The Race to Finish First

Bob’s computer is going to gather all the above information and collect it into a
set of data called a "block." Mining this block and adding it to the list of blocks that
came before is the process of creating a "chain" of blocks—hence the industry title,
"blockchain."

However, adding blocks to the blockchain is not so easy. While Bob may have
everything up to this point correctly prepared, the Bitcoin protocol does not yet give
Bob the right to add his proposed block to the chain.

The consensus mechanism is designed to force the miners to compete for this right.
By requiring the miners to work for the right to mine a new valid block, competition
spreads across the network. This provides many benefits, including time for the trans-
actions of users (like Alice) to disseminate around the world, thus providing a level
of decentralization to the network.

Therefore, although Bob would prefer to immediately create a new valid block and
collect his reward, he cannot. He must win the competition by performing the proper
work first. This is the source of the title of the Bitcoin-protocol consensus mechanism,
"Proof of Work" (PoW).

The competition that Bob must win is to be the first person to find an answer to
a simple mathematical puzzle, designed by Satoshi Nakamoto. To solve the puzzle,
Bob guesses at random numbers until he discovers a correct number. The correct
number is determined by the internal complex formulas of the consensus mechanism
and cannot be discovered by any means other than guessing. Bitcoin miners call this
number a "nonce," which is short for "a ‘number’ you use ‘once.’"
Bob’s mining device will make random guesses at the nonce, one after another,
until a correct nonce is found. With each attempt, Bob will first insert the proposed
nonce into the rest of his block. To find out if his guess is correct, he will next use
mathematical formulas (like those he used earlier) to compress his attempt into a
"block hash."
A block hash is a small and manageable form of data that represents the entire
history of the Bitcoin blockchain and all the information in Bob’s proposed block. A
block hash can look like this:

```bash
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
```

Recall now The Cascade Effect, and how it states that changing one small number in
the data before performing the mathematical computations creates a vastly different
outcome.
Since Bob is continually including new guesses at the nonce with each computation
of a block hash, each block-hash attempt will produce a widely different sequence of
numbers.
Miners on the Bitcoin network know when a miner, such as Bob, solves the puzzle;
by observing the clues that were provided earlier. Recall that the last time a miner
successfully added data to the blockchain, they provided these clues in their block
header. One of the clues from the previous block header can look like this:

```bash
"difficulty" : 1.00000000
```

This detail, "difficulty," simply tells miners how many zeros should be at the front
of the next valid block hash. When the difficulty setting is the level displayed above,
it tells miners that there should be exactly ten zeros.
Observe Bob’s attempted block hash once again, which he created after making
a guess at a nonce, adding this proposed nonce into his block, and performing the
mathematical formulas:

```bash
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
```

The block hash above has ten zeros at the beginning, which matches the number of
zeros in the difficulty level.
Therefore, the hash that Bob proposed is correct. This must mean that he guessed
a correct nonce. All the miners on the network can prove for themselves that Bob was
correct by taking all the same information from their mempools, adding Bob’s nonce,
and performing the mathematical calculations. They will receive the same result, and
therefore Bob is the winner of this round.
On the other hand, due to the Cascade Effect, if Bob’s attempted nonce had produced a block hash with the incorrect number of zeros at the front, his block hash would be invalid. The network would not afford him the right to add an incorrect
block hash to the network, and all the miners would continue searching.

#### Step Three: Bob Finds the Nonce

Once a miner discovers a nonce that produces a valid block hash, the miner has
"found a new block," and can send the signal across the Internet. The consensus
mechanism running on every other mining device can verify for themselves the calculations. Once verified, the consensus mechanism grants the miner the right both to
add the proposed block to the blockchain, and to receive the reward.
Let us return to Bob’s machine, having just guessed a correct nonce, and thus holding a valid block hash. Bob’s machine instantly sends out the winning information
across the Internet, and Bob collects his reward from the Bitcoin network.
All the other miners must readjust. Earlier, they were searching for the correct
nonce based off the information from the previous block header. However, Bob’s new
valid block includes a new block header. All the other miners on the network abandon
their current work, adopt Bob’s new block header, make many recalculations in their
underlying data, and begin their search for the next nonce.
There is no sympathy in the Bitcoin protocol for any miner’s wasted efforts. Suppose another machine on the network was also trying to mine Alice’s transaction, and
lost to Bob in the race. Only Bob earns the reward from Alice’s transaction, and the
other miner receives nothing in return for their costs and time.
For Alice, this process seems simple. She first indicated the wallet address of her
friend and sent cryptocurrency. After a certain amount of time, her friend received
the money. Alice can ignore the byzantine process of the miners that occurred between these two events. Alice may not realize it, but the PoW consensus mechanism
provides the foundation of security upon which she relies.
export const title = "Whitepaper: Chapter-2";
export const description = "Discover the strength of PoW consensus mechanisms, including the Longest Chain Rule, driving their dominance in secure blockchain networks.";

# Pow is Currently the Most Secure Form of Consensus Mechanisms

There are several reasons why PoW networks, especially Bitcoin, continue to dominate in terms of security and blockchain success. A simple, preliminary reason is
that PoW networks foster ever- increasing speed and computer power. Miners must
constantly update and innovate above their competitors to continue earning rewards.

There are yet more reasons behind PoW’s success, and The Longest Chain Rule is
one of the most notable. This rule can also be dangerous to the unwary and unprepared entrepreneur of a new blockchain product.

## Speed and Power are of the Essence

Among miners, having a faster and more powerful computer can mean earning
rewards more frequently. For miners seeking to maximize profit, competition requires constant upgrades to machinery and to a miner’s customized underlying code.

The frequency at which a device can create proposed block hashes is called "hash
power." The more hash power a collective PoW network has across all miners mining
the blockchain, the more secure thenetwork. This competitive pressure provides one important advantage in security to PoW networks, compared to alternate consensus mechanisms.

### The Network Effect: Bitcoin’s Ability to Dominate Begins

A high level of security fosters a sense of trust among users, and this can grow
a PoW network’s audience. As the audience grows, both the number of transactions
and the price of the coin increase. This attracts more miners. The rising level of miners
provides greater overall hash rate to the network, which in turn fosters a stronger
sense of trust. This increased sense of security can raise the number of users on the
network, which can increase the number of miners, and the cycle repeats.

In economics, this is classified as a "Network Effect," where a cycle of behavior encourages more of the same behavior, with compounding interest. Due to the Network Effect, and the fact that Bitcoin is the oldest PoW network, Bitcoin is increasing its
security at a rate faster than the rate of other PoW networks.

Furthermore, consider the effect caused when the price of a PoW-blockchain coin
rises. Before the rise, assume the blockchain coin is worth one dollar. A miner is
justified in spending the necessary money (on equipment, upgrades, and electrical
costs, etc.) to justify one dollar’s worth of hash rate. If the price shifts upwards to two
dollars, the miner must upgrade their entire business to justify two dollars’ worth of
a matching hash rate. If the miner does not upgrade, their competitor will, and then
the miner will no longer be able to compete for rewards.

## The Longest Chain Rule: The "Secret Sauce" of Pow Domination

There are many more reasons why PoW networks continue to dominate in security.
Yet, for our discussion, there is one element that rises above all others. It is called,
"The Longest Chain Rule," and some can argue that it is "the secret sauce" that fuels
PoW’s strength.

The Longest Chain Rule is the determining factor whenever two competing versions of the blockchain history arise on the network. The rule simply states that
whichever of the two versions grows longer first, wins. The other version is overwritten, and therefore all transactions and rewards on that version are erased. The
simplicity of this rule is a key to understanding why PoW consensus mechanisms
continue to outperform their competition.

### The Simple Effects of The Longest Chain Rule

On a surface level, this rule prevents a double spend by a network user. For instance,
consider a husband and wife accidentally attempting to spend the same money at the
exact same time, while each person is traveling in a different part of the world.

For the sake of the discussion, we are oversimplifying the following actions so that they take place within only a few milliseconds. We also oversimplify the technical details, for clarity. The full explanation of this process is provided in the [Bitcoin wiki](https://en.bitcoin.it/wiki/Main_Page), for those who would like to gain a deeper understanding.

### A Tale of Two Blockchains

Let us suppose that the husband is in Asia and the wife is in the Americas. Both
are purchasing a car. The husband uses all the funds from the family Bitcoin wallet to purchase a car at precisely 8:00 PM (UTC). The wife makes her purchase at the exact same moment, for a similar amount. After making his purchase, the husband’s transaction hash is immediately sent to a mining device in China, where it is held in the miner’s local mempool (recall that a mempool is a collection of all raw transaction
data across the network).

Let us suppose that the husband’s transaction arrives in the Chinese miner’s mempool at the exact moment that the Chinese mining equipment finds a correct nonce
and a valid block hash. The Chinese miner declares the winning information, mines
a new block, and collects a reward. All the miners in his local (Asian) vicinity (who
receive the winning information faster than in the Americas, due to proximity) complete the block verification process, increase the length of the blockchain, and begin
searching for the next valid block hash.

On the opposite side of the world, essentially the exact same actions happen. The
wife’s transaction is sent to the nearest miner, this time located in Washington state
of the United States. Just as the transaction enters the Washington state miner’s mempool, the miner discovers a valid block hash. He sends out the signal, mines a new
block, and also collects the reward (this is the same reward that the Chinese miner is
attempting to claim). All the miners in the local (US) vicinity verify the information
immediately and begin searching for a new valid block hash based on the Washington
state miner’s recent block.

### An Internal Conflict of Interest Arises Within the Bitcoin Network

Note the paradox here. There are now two versions of the Bitcoin history that are valid, yet different.

These two versions make their way across the Internet, around the world, each to
the other side. When the competing messages arrive, the Bitcoin protocol sees that there is a conflict: the same money was spent twice.

Consider how on each side of the world the miners are spending their financial and
temporal resources to further their own interests. There is no economic incentive for
either side to submit to the other, by nature. Therefore, there is a conflict of interest
within the Bitcoin network itself. The Bitcoin network would swiftly fail, were it not
for The Longest Chain Rule.

### The Longest Chain Rule: The History Which is Longer First, Wins

The Longest Chain Rule simply declares that whichever of the two competing
blockchains grows longer first, wins. The consensus mechanism erases the other version.

Let us suppose that the Chinese mining equipment is superior in this instance,
and the Chinese miner manages to discover the next valid block hash and send out
the signal before the Washington state miner can do likewise. Across the world, the
moment the information arrives that the Chinese miner completed yet another valid
block, the Bitcoin protocol erases the Washington state miner’s version of the Bitcoin history.

There is no sympathy for any wasted efforts, nor for any misunderstandings be-
tween the wife and her car dealer. The Bitcoin protocol’s consensus mechanism simply presses forward. The Washington state miner’s rewards disappear, as though they
never occurred. The wife’s purchase of a car likewise evaporates.

*(Typically, a normal and prepared car dealer utilizing cryptocurrency would not consider a
customer’s transactions acceptable until several new blocks were added to the blockchain. In
this manner,cryptocurrency users can ensure that a transaction is beyond contestation before
the customer can, for example, drive a new car off the lot.)*

The Washington state miner gets a raw deal in this scenario, but the network benefits as a whole. The Longest Chain Rule provides the necessary security to prevent
a Double Spend. The network accurately recorded one family member’s purchase of
a car, prevented the mistaken double spend, and ensured that the most competitive
miner received a just reward.

This example illuminates the importance of The Longest Chain Rule. However,
there is a dark side to this rule for the unsuspecting and unprepared blockchain
developer.

## The "Easy" Way to Destroy a PoW Network: The 51% Attack

Here’s where intrigue enters the picture. The "easiest" way to steal money on a PoW
blockchain (such as Bitcoin) is to perform a 51% Attack.

In this attack, the malicious actor first spends cryptocurrency in exchange for something of value, which they take from their victim. Next, the malicious actor creates an
alternate version of the PoW network’s history wherein those transactions never took
place. Using advanced mining equipment, the malicious actor then "attacks" the PoW
network by mining blocks to this "false" history faster than the rate at which other
miners on the PoW network can mine blocks to the "true" history.

Assuming the malicious actor has a sufficient hash rate, as this "false" history grows
longer than the "true" history, the Longest Chain Rule will cause the consensus mechanism to overwrite the "true" version. The earlier transactions the malicious actor
made would be as though they never occurred. Therefore, the malicious actor would
keep both their original funds and whatever item of value they exacted from their
victim.

This is known as the 51% Attack. The number 51% derives from the fact that to
successfully perform this attack, the attacker must add enough hashing power to the
overall PoW network to form a majority of the hash rate.

## Size is Yet Another Reason Behind Bitcoin’s Current Success Among PoW Networks

Today, Bitcoin’s overall hash rate is enormous. The collective of computers around
the world mining Bitcoin is effectively the largest supercomputer ever created by man.
As of the writing of this paper, some estimate that [the Bitcoin network consumes more
electricity than the entire country of Denmark](https://arstechnica.com/tech-policy/2017/12/bitcoins-insane-energy-consumption-explained/), and the number of miners continues
to grow.

Therefore, to attempt a 51% Attack against the Bitcoin network could cost millions,
if not billions of dollars in computer hardware. It would also require a sustained
consumption of electricity that is likely unfeasible for a single geographical location,
and would be expensive even for a decentralized-hardware network. So long as the
miners of Bitcoin remain interested in the Bitcoin network, therefore, Bitcoin has a
level of security that is nigh impenetrable.

*We will return to the proposition of the miners’ ability to choose a different network to mine,
later.*

## The "Hard" Way to Destroy a PoW Network: The Genesis Attack

### A Genesis Attack on the Bitcoin Network

Recall that according to the original version of the Bitcoin protocol, sometimes
called the ["vanilla" version](https://www.worldcryptoindex.com/bitcoin-scaling-problem-explained/) , the Longest Chain Rule only requires that the blocks
in the longest chain all be properly mined. Furthermore, recall that computers can
endlessly duplicate code.

Finally, note that during our explanation, when describing a malicious actor’s at-
tempt to create an empty, meaningless blockchain history, we use quotation marks
when employing the word, "false." Likewise, when describing the blockchain history
trusted by the people on the network, we include the word "true" in quotations.

We do this because at the core level, the consensus mechanism is purposefully
blind regarding any human user’s preference between "truth" and "false." The code
only sees "truth" in terms of properly mined blocks, and overall blockchain length.
Nothing more.

Now suppose the existence of a supercomputer a thousand times more powerful
than the entirety of the Bitcoin-miner network. This supercomputer could, in theory,
stealthily re-create and execute the initial code that spawned the very first block of
the Bitcoin blockchain—the "Genesis Block." The supercomputer could then grind out block hashes, one-by-one, mining meaningless blocks and adding them to this empty,
"false" version of the Bitcoin history.

Once this meaningless blockchain’s length sufficiently exceed the so-called "true"
blockchain used today, the supercomputer could then release its "false" version to the
Internet.

Throughout the world, (assuming the vanilla protocol) the Bitcoin network would
automatically recognize the "false" blockchain as the correct blockchain! This would
all be according to the code. The so-called "false" blocks would be properly mined,
and the length would be longer than the chain that users currently trust. The vanilla
protocol would, in theory, replace the so-called "true" history with the empty variant.

It might seem to users like a virus being uploaded to the Internet. It could destroy
all human trust in the current version of the Bitcoin protocol, wreaking financial havoc
throughout the cryptocurrency realm. While users of the Bitcoin protocol would natu-
rally protest, the entire operation would be entirely in agreement with the underlying
code.

When observing Bitcoin’s current hash power, the creation of such an anti-Bitcoin
supercomputer is clearly not feasible in the immediate future. Assuming Bitcoin min-
ers remain interested in the Bitcoin network, the risk of a Genesis Attack on Bitcoin
is essentially non-existent.

However, consider the implications of the Genesis Attack on unsuspecting or un-
derprepared smaller PoW blockchain projects.

### The More Realistic Dangers of The Genesis Attack

Let us assume a naïve blockchain entrepreneur building a new product. They are
generally aware that malicious actors throughout the world are likely to attack their
blockchain, stealing funds and otherwise causing trouble. Therefore, the naïve entrepreneur decides to implement what they believe is the most secure method of a
blockchain consensus mechanism, PoW, and they offer ample financial rewards to
miners to incentivize a secure network.

The entrepreneur and their entire audience may not realize it, but so long as their
network’s overall hash rate remains below the threshold of an attack by even an
average supercomputer, their entire blockchain history is vulnerable to complete annihilation. A technically astute competitor, seeing the vulnerability, and possessing
ownership of the requisite computer hardware, would be able to create an empty and
longer version of the same blockchain code and vaporize their competitor’s financial
records.

The cryptocurrency industry is young, and few but the most advanced of develop-
ers understand the many ways in which blockchain competition can be technically
eliminated. Therefore, we have seen but a few serious cases of the Genesis Attack.
One notable instance occurred when an original Bitcoin developer, Luke-jr, used a variation of the attack to destroy a blockchain project called Coiledcoin. Luke- jr per-
formed this attack out of a belief that Coiledcoin was a [disingenuous project](https://bitcointalk.org/index.php?topic=56675.msg678006#msg678006). Setting
aside any human sentiment on either side of the event, the fact stands that Luke-jr’s
variation of the Genesis Attack was the end of the Coiledcoin network.

The complexity in establishing a secure PoW blockchain remains a challenge for
would-be entrepreneurs. Furthermore, there are existing PoW developers that are not
fully aware of their vulnerability. Likewise, there are would-be malicious actors that
have yet to realize the many methods available to cause frustration. The potential
danger surrounding the issue of the Genesis Attack shows the relative youthfulness
of the cryptocurrency industry.

For a PoW blockchain network to maintain Bitcoin-level security, therefore, it must
maintain a hash rate that is high enough to constantly mine blocks faster than a
potential competitor could either perform the 51% Attack (destroying the most recent
of transactions), or the deadly Genesis Attack (complete annihilation).

## The Financial and Eco-Unfriendly Problems With All PoW Networks

The problems with young PoW networks do not stop there, and furthermore, even
Bitcoin’s PoW network has issues: the security of a PoW network comes at a high cost
to the environment, and miners have no obligation to mine any particular network.

### PoW Networks Are Expensive

Some estimate that by 2020, the Bitcoin network alone will consume more elec-
tricity than the entire world currently consumes (as of [2017](https://arstechnica.com/tech-policy/2017/12/bitcoins-insane-energy-consumption-explained/)). Having just one PoW
network in existence, therefore, is already strain enough on our environment. It is
also a burden on our infrastructure and our worldwide economy. On the one hand,
adding additional PoW blockchains to the world can serve the purpose of forcing
free- market competition on the Bitcoin developers, encouraging ethical and innovative behavior. Therefore, some competition among PoW networks is likely useful.

However, as a human species, we can consider that there are more financially sound
and eco-friendly methods of innovating with blockchain technology without always
directly competing with Bitcoin PoW security. Our innovation, delayed Proof of Work,
is one response to this fact, as we will soon discuss.

### Miners are Free to Mine Other Networks

In November of 2017, for a few hours the majority of Bitcoin network miners
switched their hash power to a competitor’s PoW network, the "[Bitcoin Cash](https://www.coinwarz.com/mining/bitcoincash/hashrate-chart)" net-
work. This switch was the result of clever software engineering on the part of the
Bitcoin Cash team.

The team recognized that most miners on the Bitcoin network are set to automatically mine whichever network is most profitable. Therefore, the team conducted a
calculated change in their underlying protocol that caused the profitability of the
Bitcoin Cash network to dramatically increase. The majority of the world’s Bitcoin
mining equipment, running via automation, recognized the higher profitability and
switched to the Bitcoin Cash network automatically.

While Bitcoin Cash’s play for a majority hash rate only proved effective for a matter
of hours, their accomplishment raised awareness to a tacit principle in the network:
Bitcoin’s hash rate is not bound to Bitcoin. The hardware is free to serve any compatible network the miners choose.

At the time of the writing of this paper, between Bitcoin and Bitcoin Cash, \~80% of
the available hash rate is aligned with the former, and \~20% with the latter. There is
speculation in the industry that if the Bitcoin Cash network creates a more favorable
position, the balance of hashing power could change on a long-term basis. Furthermore, there are many other blockchain competitors who may gain the attention of
Bitcoin’s miners in the future.

Were a shift in the balance of hash rate to occur, Bitcoin would no longer be the
leader of security in the cryptocurrency realm. The price of Bitcoin would likely drop
as users realized the resulting lack of security leadership. This might cause more
miners to switch to a more profitable network to cover the cost of operating their
expensive hardware. As miners abandon Bitcoin, and as users continue to leave, the
situation becomes a reversal of the Network Effect. The Bitcoin network would come
crashing downwards at an ever-compounding rate.

This is all theoretical, but it raises yet another concern that we need to illuminate:
the security of a blockchain depends on many things, including the potentially fickle
support of human blockchain miners. Our innovation, delayed Proof of Work (dPoW),
takes this fact into account as we empower members of the Komodo ecosystem with
Bitcoin-level security. Before we finally turn to our own solution, we must discuss the
primary competitor to the PoW consensus mechanism, Proof of Stake (PoS).

### The Primary Alternative Consensus Mechanism: Proof of Stake

Perhaps the most popular alternative consensus mechanism is Proof of Stake (PoS).
In this mechanism, blocks are mined not by miners performing work, but rather by
any user "staking" their coins on the open network for the right to mine blocks.

The meaning of "staking" has different variations depending on the specific rules
set forth by the developers of the unique variant of the PoS consensus mechanism. In
general, staking one’s coins means placing them as collateral on the open network in
exchange for the right to mine new blocks.

Users who stake their coins, thereby, can periodically extract a portion of the mempool, mine new blocks, and earn rewards. There is no need to perform any hardware-
expensive proof-of-work calculations, as the user’s incentive to be honest is encouraged by the fact that their own wealth hangs in the balance.

### The Security Risks and Shortcomings of PoS

The downside to PoS is that a user who simply leaves a large portion of wealth
staked (and therefore continually claims rewards) gradually becomes a centralized
point of wealth through the power of compound interest. On PoS networks, monopolies are a constant danger. The owner of a monopoly has power over the well-being
of the network.

Once a majority of the supply is obtained, the owner gains a position known as
"Nothing at Stake." The owner can mine "false" blocks to the PoS blockchain and use
their own majority supply over the network to declare these "false" blocks valid. All
other stakeholders on the network must adopt these "false" blocks, lest the majority
holder use their strength to declare competing blockchain versions as invalid.

If a non-majority holder attempts to challenge the monopoly holder’s version, the
non-majority holder can achieve little more than the loss of coins they placed at
stake. Compare this with non-majority holder in a PoW system: the question over the
"truth" of the blockchain history depends not upon ownership of wealth, but upon
the miner’s innovation and performance. PoW-based systems do not suffer from the
risk of monopolies, therefore, as majority stakeholders gain no unique control over
the mining of new blocks.

Variations of PoS, including the popular Delegated Proof of Stake (DPoS) and Delegated Byzantine Fault Tolerance (DBFT) systems, do not resolve the underlying issue
of monopoly ownership and centralized manipulation. In a vanilla PoS system, the
malicious actor needs only to purchase a majority supply of the coin to mine "false"
blocks. In a DPoS/DBFT type system, wherein the ecosystem stakeholders elect and
endow delegates with the responsibility to mine new blocks, the malicious actor has
only to compromise most of the delegates. Thereafter, the compromised delegates can
mine "false" blocks, and the users of the ecosystem have no direct means to retaliate,
beyond abandoning the network.

This is not to say that PoS and its variants have no use cases. Indeed, there are
scenarios in which PoS can be useful for entrepreneurs. In the Komodo ecosystem,
our dPoW consensus mechanism can provide security to networks that use either
type of consensus mechanism.

After the following section summary, we finally turn our attention to our dPoW
consensus mechanism.

### A Summary of the PoW Consensus Mechanism

In short, the PoW consensus mechanism, as designed by Satoshi Nakamoto, is
currently the soundest method of blockchain security. It solves the Double Spend
problem and creates a secure network, capable of transferring financial value. Furthermore, competition among miners and the Longest Chain Rule create fairness on
the blockchain. The combination of features provides a high level of defense against
two of the most dangerous methods of blockchain destruction—the 51% Attack and
the Genesis Attack—assuming a strong overall hash rate on the network.

New PoW blockchains can opt to compete directly with Bitcoin’s hash rate, and
some level of competition is good for the ethical values and innovative power of the
cryptocurrency industry. However, it is not necessary, cost-effective, nor eco-friendly
that every new blockchain innovation requiring security should attempt to compete
directly with Bitcoin. Not only is this unsustainable, but it is also unreliable, as it
depends on the arbitrary choices of the decentralized network of miners around the
world.
export const title = "Whitepaper: Chapter-3";
export const description = "Discover Komodo's innovative dPoW consensus mechanism, leveraging the power of the Bitcoin network to enhance security and scalability.";

# The Komodo Solution

## Abstract of the Delayed Proof Of Work Consensus Mechanism (dPOW)

Komodo presents a technology, the delayed Proof of Work consensus mechanism,
that solves the problems described above. Komodo’s unique consensus mechanism
provides the same level of security as the strongest PoW network, without attempting
direct competition. Instead, Komodo’s consensus mechanism uses the chosen PoW
network as a storage space for "backups" of Komodo transactions. By this method, in
the event of an attempted attack on Komodo’s blockchain history, even a single surviving copy of the Komodo main chain will allow the entire ecosystem to overwrite
and overrule any of the attacker’s attempted changes.

In a key difference separating Komodo from regular PoW networks, our dPoW consensus mechanism does not recognize the Longest Chain Rule for any transactions that are older than the most recent "backup" of the Komodo blockchain. For conflicts that may arise which refer to transactions that are older than the most recent "backup," our consensus mechanism looks to the backups in the chosen PoW blockchain to find the accurate record.

Furthermore, entrepreneurs who build independent blockchains (smart chains) in
the Komodo ecosystem can likewise elect to have backups of their own records inserted into the Komodo main chain. In this manner, the records of the entrepreneur’s
chain are then included in the backup that is pushed into the protective hash rate
of the main PoW blockchain (Bitcoin). Thus, entrepreneurs and developers in the
Komodo ecosystem can have their independent blockchains protected by the chosen
PoW network’s hash rate.

Therefore, to destroy even the smallest smart chain that is employing Komodo’s
dPoW security, the attacker would have to destroy: a) all existing copies of the smart
chain; b) all copies of the Komodo main chain; c) the accompanying PoW security
network into which the dPoW backups are inserted (Bitcoin). This endows the Komodo ecosystem with higher than Bitcoin-level security, while avoiding the excessive
financial and eco-unfriendly costs.

In addition, the dPoW security provided by Komodo is not only greater than Bitcoin, but is also more flexible. The Komodo security services are performed by notary nodes, chosen through a stake-weighted vote. Notary nodes have the freedom to
switch notarization to another PoW network. Reasons the notary nodes might elect
to switch networks could include an event where worldwide miners’ hashing power
changes to another PoW network, or the cost of notarization to the current PoW network becomes more than necessary. Through this flexibility, the Komodo ecosystem
maintains both a superior level of security and a more flexible and adaptive nature
than Bitcoin itself.

### A Note About Komodo’s Iguana Core Technology

All the following processes are supported by a deeper Komodo technology called
Iguana Core. Readers of our entire white paper will note that Iguana Core is featured
in each section. This is because Iguana Core is the heart of the underlying technology
that enables the vast Komodo ecosystem to work together. The Iguana Core code
itself is complex and to fully explain would require a separate white paper.

In short, Iguana Core is a collection of code that serves many purposes. One function of Iguana Core is to empower the blockchain technologies Komodo either builds
or adopts to act in coordination with each other. Often, Iguana Core can advance their
initial capabilities beyond original expectations. In the case of dPoW, the code that
underlies notary-node functionality spawned from Iguana Core technology.

Iguana Core is coded in the C programming language—the language of choice
of our lead developer, JL777. The C language is designed to enable computers to
process high volumes of information in a secure manner at high speed. This aligns
with Komodo’s directives to provide security and scalability to our users.

### A Brief Discussion on the Security Provided by the Notary Nodes

Security is the foundational aspect of the Komodo ecosystem. Therefore, for the
reader, we must first discuss the nature of the security the notary nodes provide.
More detailed explanations on individual components will follow.

The Komodo ecosystem uses a stake-weighted vote to elect parties who will run
sixty-four separate "notary nodes." These notary nodes perform the "backup" process
via automation provided by the Iguana Core software that runs at the heart of our
system. These backups are called "notarizations." Each notarization performed by the
notary nodes acts as a marker of the "true" history for the Komodo ecosystem, and
this marker’s accuracy is secured by the hash power of the chosen PoW network.

The notary nodes work together in a decentralized and trustless manner both to create each notarization and to write it to the chosen PoW network (Bitcoin). Frequency
varies between two to six notarizations per hour, and the yearly cost to perform this
service is \~180 BTC. Funds for this service were raised as a part of our initial Komodo
ICO, and our holdings allow us to continue this method for many years before we
will be required to implement a business model to replenish our reserves.

With our dPoW mechanism, each confirmation on the chosen PoW network is also
a confirmation of the entire Komodo ecosystem’s history. The only sacrifice that is
made is the time it takes to push the Komodo ecosystem’s records into the protection
of the main hash rate. For this reason, we name our consensus mechanism, "delayed
Proof of Work" (dPoW).

Our consensus mechanism is designed to keep the advantages provided by the
PoW system, circumvent the excessive financial and eco-unfriendly overhead costs,
and avoid the security risks found in a PoS system. We accomplish these measures
by several means. The most important measure is that all actions a notary node takes
are publicly verifiable, and the Iguana Core software running on the users’ machines
verifies notary nodes’ actions. The notary nodes themselves are not arbiters of "truth."

Therefore, the only type of "false" behavior a malicious notary node can perform
is to withhold notarization. There are sixty-four notary nodes. The minimum number of notary nodes required to maintain the Komodo ecosystem is thirteen. Thus,
a malicious actor would have to compromise fifty-one notary nodes to shut down
the Komodo ecosystem. Such an action would be uneconomic, as this would be destroying the access to the financial rewards a notary node receives for performing its
duties. By this design, notary nodes have only one economically favorable position:
to properly transfer the records of the Komodo ecosystem into a secure location and
to increase Komodo’s market share and value.

For the average user, when performing a trade of goods and services where security
is desired, the user simply needs to wait until the notarization process is complete.
After the notary nodes are finished, the only way to break the security protecting
their transaction history requires breaking the security of the chosen PoW network
(Bitcoin). The Iguana Core code running in the main Komodo software automates the
verification process. Entrepreneurs and developers should be aware of this information as they design business models and services for their users.

Thus, Komodo’s dPoW consensus mechanism maintains the security innovated
by Satoshi Nakamoto, and because it enables the Bitcoin hash rate to serve more
independent blockchains than just the single Bitcoin blockchain, dPoW even expands
on Nakamoto’s original design.

## The Notarization Process

### Step One: Gathering the Appropriate Data

The process of notarization is simple. Roughly every ten to twenty-five minutes,
the notary nodes perform a special block hash mined on the Komodo blockchain and
take note of the overall Komodo blockchain "height" (i.e. the number of total blocks
in the Komodo blockchain since inception). The notary nodes process this specific block in such a manner that their signatures are cryptographically included within
the content of the notarized data.

(All examples herein are estimated based off this actual KMD notarization to the BTC network:
[https://blockstream.info/tx/313031a1ed2dbe12a20706dff48d3dffb0e39d15e3e4ff936d01f091fb3b8556?expand](https://blockstream.info/))

The pieces going into the notarization process could look like this:

```bash
0a88371cc63969d29492110592189f839557e606db6f2b418ecfe8af24451c07
This is the "block hash" from the KMD blockchain—mined and cryptographically signed by the notary nodes
```

#### Block 607240

*   This is the blockchain "height" of the Komodo blockchain at the time of notarization (i.e. the total number of KMD blocks ever created)

#### KMD

*   The letters "KMD" are added into the notarization mixture to indicate the name of the blockchain to which this notarization belongs

The notary nodes will take these three pieces of information and compress them into
a format that is more computer-friendly. The result will look like this:

```bash
6a28071c4524afe8cf8e412b6fdb06e65795839f189205119294d26939c61c37880a084409004b4d4400
```

The above number can be said to be a cryptographic representation of all that has
happened on the Komodo blockchain up to this point in time. According to the Cascade Effect, were an attacker to attempt to go back in the history of the Komodo
blockchain and change even a single character of data, and then perform the same
hashing formulas in the Komodo code, the number above would dramatically change.

This makes the notary nodes’ notarization a useful backup, assuming this number
is in a safe location where anyone on the Internet can view and verify it. It enables
a single surviving copy of the "true" Komodo main chain to identify itself to the
rest of the Komodo network, as only the "true" data can produce the same result.
On the other hand, an incorrect history of the Komodo network will not be able to
produce the same notarization. Through the automation in the Iguana Core software
that underlies the Komodo ecosystem, all users will align with the "true" blockchain
history and ignore any malicious actors’ "false" attempts.

### Step Two: Notarizing the Data to a Secure Location

Naturally, for security purposes this number cannot simply be saved to one person’s local computer, or be written down on a piece of paper. Were the number to be
in such a centralized location, a would-be attacker could simply destroy the backup,
or replace it with a "false" version. For the number to be useful, it must be placed
in a secure and decentralized location. Here is where Komodo adopts security from
another network: Komodo will perform a simple transaction in which it writes the
above number into the data history of the strongest PoW blockchain (currently Bitcoin). This location is as secure as the miners’ hash rate makes it, and the location is
decentralized, by nature.

To place this information in the accompanying PoW network, the notary nodes will
use a feature that exists at the core of the Bitcoin protocol when making a transaction.
The feature is called "OP\_RETURN," and it allows for a message to be added to the
blockchain, permanently, as a part of performing a transaction.

A notable use of the ability to write messages to a PoW blockchain is found in the
first actions of Satoshi Nakamoto himself (themselves). In the first Bitcoin block ever
mined, Satoshi used a feature like OP\_RETURN (Nakamoto used a feature called "coinbase," which is similar to OP\_RETURN. A primary difference
between coinbase and OP\_RETURN is that coinbase is used by miners when mining a block, whereas
OP\_RETURN can be used when performing transactions.) to include this [message](https://en.bitcoin.it/wiki/Genesis_block):

```bash
03-Jan-2009 Chancellor on brink of second bailout for banks
```

Readers who have downloaded the Bitcoin blockchain to their local computer, and
who possess the knowledge necessary to inspect the raw Bitcoin data, can discover
these very words written to their own hard drive. The important thing to understand
for our discussion is that any message written to a secure and decentralized PoW
blockchain is viewable and verifiable to all.

The permanence and security of OP\_RETURN messages are a core aspect of dPoW’s
security. In the event of a powerful attack on the Komodo network, there need be no
argument over the correct notarized marker upon which the ecosystem members
should rely. The Iguana Core code running at the heart of each user’s Komodo soft-
ware can continue securing, decentralizing, and distributing the accurate version of
the Komodo history as though the attack never occurred.

### Step Three: Notarizing the PoW Network Information Back to the KMD Main Chain

One final step remains to complete the loop of security between the KMD main
chain and the chosen PoW network. The KMD blockchain must record within its own
records the specific location where it placed this backup into the PoW blockchain.
This enables the Iguana Core software to identify the location of the most recent
notarization.

To create this reminder, the notary nodes will now gather one more piece of information, this time drawn from the accompanying PoW network: the transaction hash
(txid) identifying the location of the first notarization. This information could look
like this:

```bash
313031a1ed2dbe12a20706dff48d3dffb0e39d15e3e4ff936d01f091fb3b8556
```

The notary nodes will combine it with all the information that has come before. The
result will be transformed, again, into a computer-friendly version:

```bash
6a28071c4524afe8cf8e412b6fdb06e65795839f189205119294d26939c61c37880a0844090056853bfb91f0016d93ffe4e3159de3b0ff3d8df4df0607a212be2deda13130314b4d4400
```

This number is a compressed cryptographic representation of everything that has
happened in the Komodo ecosystem up to this point in time. The notarization is
placed as a transaction message directly into the KMD main chain itself. It enables
the Komodo ecosystem to know how to find a reference of its own history.

As each notarization is built upon all the notarizations that came before, Iguana
Core does not need to monitor each notarization. Rather, it only needs to observe
the most recent iteration. This is favorable for Komodo security, as there is always a
possibility that the chosen PoW network (Bitcoin) could fail. In this event, the notary
nodes would place their next notarization in a competing PoW network (such as Bitcoin Cash) and the entire Komodo ecosystem would remain secure. The notarizations
in the failing PoW network would no longer be required to verify ecosystem accuracy.

## Understanding Security and Economic Incentives in the Komodo dPoW Network

The nature of mining in the Komodo ecosystem serves as an incentive to motivate
the notary nodes to perform their job well. This setup is also a principle method
by which the Komodo ecosystem dramatically reduces the overhead costs necessary
for it to function. Portions of the mining rewards are available not just to the notary
nodes, but also to all members of the Komodo ecosystem, through various means.

The Komodo network on a surface-level is a minable network, like other PoW
networks. Any technically savvy user can activate a device capable of mining the
Komodo network, and thereby process users’ transactions, mine blocks, and receive
rewards. For these miners, the Komodo protocol functions in almost the exact same
manner as the Bitcoin blockchain’s mining rewards function.

Understanding the similarities will explain to the reader the motivations for the notary nodes and other Komodo miners to secure the Komodo network. The differences, on the other hand, are explained in [Part V](/historical/whitepaper/chapter8/) of this paper. (See the section regarding the 5.1% rewards allocated to all users who hold at least 10 KMD in their wallet address. This 5.1% reward is given to users out of the funds that would normally be given to a Bitcoin miner as a method of minting new Bitcoin coins.)

### "Easy Difficulty" in dPoW: The Key to Notary Nodes’ Financial Incentives

The foundational similarity to understand is that with each block header, clues are
provided for miners to find the next valid block hash. The specific clue, "difficulty,"
changes with each block header.

Under normal circumstances on a PoW blockchain, with each block header the
difficulty level can change. The Bitcoin protocol itself decides what the difficulty for
the next valid block should be. The difficulty is decided based on the amount of
overall hash power mining the network. If many miners are active, then the hash rate
is high, and the Bitcoin protocol sets the difficulty to a higher number. On the other
hand, if the hash rate is low, then the protocol sets the difficulty to a lower number.
Recall that the "difficulty" level determines the number of zeros at the beginning of
the next valid block hash. The more zeros at the beginning of a valid block hash, the
more unlikely each attempt at finding a valid block hash will be.
When the Bitcoin protocol was in its infancy, the difficulty setting was easy. In fact,
the block hash we used earlier as an example is, in truth, the very first block hash
ever created—by Satoshi Nakamoto himself (themselves).

```bash
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
```

He (they) designed the difficulty setting to encourage the network to find new block
hashes once every ten minutes, on average.

For a computer, to guess within ten minutes a nonce that will produce a block
hash beginning with ten zeros is relatively easy. It is so simple, in fact, no special
computer is required. Early Bitcoin miners could use nothing more than the average
desktop machine, having the CPU—the small heart of the computer—performing the
calculations.

As more miners joined the network, however, the Bitcoin protocol automatically
increased the difficulty. This maintained the speed at which the pool of all miners
discovered new blocks, despite the increased size of the pool. Stabilizing the speed
created several benefits, including an amount of economic predictability upon which
users can rely.

Today, at Bitcoin’s current level of overall hash power, a valid block hash requires
a much higher level of difficulty. Here is a recent successful block hash:

```bash
0000000000000000002d08398d6f21f038019600266b419bad5ab88add5b638d
```

There are seventeen zeros, and to find a valid block hash at this level requires a
prodigious effort.

In the race to win blockchain rewards, miners all over the world have built entire
farms of specialized equipment for mining. The small CPU of a desktop is no longer
useful, and the time of "easy difficulty" on Bitcoin has passed.

### The dPoW System has Sixty-Four Elected Notary Nodes

Here is where our dPoW consensus mechanism diverges from the Bitcoin proto-
col’s limitations. In addition to performing the notarizations of the Komodo ecosystem, notary nodes are also a special type of blockchain miner. They have a certain
feature in their underlying code that both enables them to maintain an effective and
cost-efficient blockchain ecosystem and provides the notary nodes with a financial
incentive. The combination of benefits prevents the Komodo ecosystem from falling
into the trap of directly competing with other PoW networks for hash-rate security
status.

### Each Notary Node Gets One Chance Per Every Sixty-Five Blocks to Mine on Easy

Each individual node periodically receives the privilege to mine a block on "easy
difficulty." In other words, while the rest of the miners in the Komodo ecosystem
are mining at a calculated difficulty level, the notary nodes occasionally receive the
chance to mine as though they are alone on the network.

The notary nodes’ "easy difficulty" setting operates in a cyclical manner, with each
notary node on its own cycle. At the start of the cycle the notary node holds the "easy
difficulty" ability until it mines one "easy" block. Then the Iguana Core code removes
the ability for the next sixty-four blocks. After the sixty-four-block period passes, the
notary node can once again attempt to capture a block on "easy difficulty."

Therefore, while everyone else on the network mines at an adjustable level of difficulty according to the normal PoW consensus mechanism (which keeps the overall
speed of the Komodo network stable) the notary nodes have a chance to step outside
the normal rules. For every sixty-five-block period on the Komodo blockchain (See following section of the Free-for-All Period) , the
odds that a block will be mined by a notary node, as opposed to a normal miner, are
essentially 3:1.

Since the rest of the miners have an adjustable difficulty ratio, it does not matter
how many more miners attempt to mine Komodo. Most of the valid blocks will
always be found by the sixty-four elected notary nodes, even were the entire hash
power of the Bitcoin network to somehow switch all its attention to mining Komodo.

The mining rewards that a notary node receives through this feature are \~50 KMD
per day. This reward occurs regardless of KMD’s popularity, market value, or even of
the competition from normal KMD miners. The reward notary nodes receive creates an economic incentive for each party controlling a notary node to support and protect
the Komodo ecosystem, and to increase the relative value of this daily \~50 KMD
reward.

### The Free-for-All Period

Every 2000 blocks, the Iguana Core code removes the easy-difficulty mining ability
from all notary nodes for a sixty-four-block period. This gives the entire ecosystem the
chance to freely mine the Komodo blockchain. The primary purpose of the Free-for-
All period is to recalibrate the difficulty level of all miners on the Komodo network.
It also gives a fair chance to all members of the Komodo ecosystem to capture mining
rewards.

The notary nodes continue the notarization process itself throughout the Free-for-
All mining period. When the Free-for-All period concludes, the notary nodes regain
their abilities and resume mining the current chain.

## Komodo’s Protective Measures in Action

There are myriad ways that an attacker can assail a blockchain project, and the
Komodo ecosystem is well prepared. In this foundational paper, we only discuss two
of the most crucial attacks—the 51% Attack and the Genesis Attack.

In a separate technical white paper, written by our lead developer, we provide
several more discussions on how Komodo responds to many other forms of attack.

Some of this earlier paper is now deprecated, and therefore it has been removed from most locations on our website. There remain relevant sections regarding Komodo’s protections against various other attacks. Please reach out to our team directly for a copy of this white paper, if interested.

Some mentioned therein include the Sybil Attack, the Eclipse Attack, and more. We
encourage any reader searching for information about the deepest levels of Komodo
security not only to read the accompanying white paper, but also to reach out to our team directly.

### Notarizations Provide a Defense Against Both the 51% Attack and the Genesis Attack

By relying on the notarizations in the chosen PoW network’s hash rate (Bitcoin),
users in the Komodo ecosystem are well protected from both the 51% Attack and the
Genesis Attack. Recall that in a 51% Attack, the attacker first makes a transaction and
then erases it by providing 51% of the total hash rate to a "false" blockchain where the
transaction never occurred. In the Genesis Attack, the attacker recreates the genesis
block of a blockchain and mines an entirely false history. For either of these attacks to
play any part in the Komodo ecosystem, the successful attack would have to destroy
every transaction at every level it is recorded.

First, let us consider the implications of the notarization process provided against
the Genesis Attack. Once an independent blockchain has even just a single transaction
pushed through the notarization process into the chosen PoW network, that notarization protects against the Genesis Attack. To successfully complete a Genesis Attack
against a Komodo-built blockchain, the attacker would have to destroy the chosen
PoW network’s records from that moment going forward. The attacker would also
have to destroy the KMD main chain from that moment forward, and the entire independent smart chain. The likelihood of achieving this task is effectively as probable as
performing a Genesis Attack on the chosen PoW network itself.

The Komodo ecosystem is also well protected against the 51% Attack, so long as
users wait for a desirable number of notarizations. Consider a transaction that is
recently performed on an smart chain in the Komodo ecosystem. While the notary
nodes have not yet notarized the transaction into the KMD main chain, then it is
plausible that during this approximately ten-minute period an attacker could successfully perform a 51% Attack on this transaction. The attacker would simply make
a transaction, and then provide 51% of the total hash rate to a "false" version of the
independent smart chain to erase the transaction. Therefore, users should always wait
until they receive at least one notarization to the KMD main chain before considering
any transaction final.

There are methods and resources available for developers and entrepreneurs who
wish to securely alleviate any wait time a user might experience during this ten-minute period. The Trust API (briefly explained in [Part III](/historical/whitepaper/chapter6/) of this white paper), our forthcoming CHIPS technology, and our Crypto Conditions and MoM smart-contract
technology (currently in beta and alpha stages) can serve these purposes. The Speed
Mode setting on BarterDEX is a demonstration of the Trust API feature. It allows users
to have a certain amount of high-speed transaction bandwidth available, without
having to wait for any notarizations. Development on these features is currently a
top priority, and progress is proceeding quickly. Please reach out to our team for
more details, if these features are of interest.

Once the transaction reaches the KMD main chain, at this point, the attacker would
have to successfully perform the 51% Attack against both the KMD main chain and
the independent smart chain. This is already quite difficult to achieve, as it would
require overcoming the notary nodes and other KMD miners, while simultaneously
attacking the independent chain. Entrepreneurs, developers, and users should decide
for themselves how much trust they wish to place in the system at this point of the
notarization process.

When considering large sums of money, the need for protection grows. A large
sum of money can be both a single large transaction, or it can be the collective value
of many small and normal-sized transactions that build up over hours, days, and
years. These transaction histories need protection against the sophisticated blockchain
attacker. It is for this reason that the notarization process exists.

Once the notary nodes have pushed the most recent version of the Komodo ecosystem’s history into the chosen PoW network (Bitcoin), the entire ecosystem relies only on that notarization as the arbiter of truth. All transaction records that have been
pushed into the chosen PoW network can only be rescinded by altering the chosen
PoW network itself (while simultaneously altering the histories of the KMD main
chain and the independent smart chain). Accomplishing such a task is highly improbable (though we warn the reader never to consider any attack impossible).

Therefore, any record that has been on the Komodo main chain for at least one notarization has a fortress of hash rate and other security measures at its guard. So long
as users and developers are mindful to wait for the desired number of notarizations
to secure their payments, both the 51% Attack and the Genesis Attack are highly unlikely either to be successful, or to provide economic value to the would-be malicious
actor. Nevertheless, we remind all users of our ecosystem to consider their own vigilance and mindfulness as the most effective protection against the would-be attacker. Users, entrepreneurs, and developers utilize all aspects of the Komodo network at their own risk.

#### Considering an Attack on the Notarization Process

To create a notarization for the KMD main chain, the minimum number of notary
nodes required is 13. If the notary nodes themselves come under attack and must
work to maintain access to the Internet, just 13 of the full 64 are required for the
Komodo ecosystem to continue its operations.

In the possible event of a disconnect from the minimum number of notary nodes,
chains in the Komodo ecosystem should simply be on the alert. Users, developers,
and entrepreneurs would simply need to wait for the notary nodes to regain access to
the Internet and resume the notarization process before considering any transaction
final.

For this reason, the position of a notary node is held with high importance, and
the parties which gain these positions are measured foremost by their Information
Technology experience and capabilities. Komodo stakeholders are responsible to vote
for candidates that are the most qualified to perform in the notary-node duties.

## The dPOW Consensus Mechanism is Inherent in all Komodo Smart Chains

These security features extend to any smart chain relying on the notarization process. The primary difference between an smart chain and the main chain is that the
main chain notarizes to an exterior PoW network (Bitcoin), whereas the smart chain
notarizes to the KMD main chain.

The notarization for the smart chain is performed by the notary nodes as a service
to the independent developer and entrepreneur. Notary nodes create a notarization
of the smart chain and write it into the KMD main chain. Then they write their actions
into the smart chain itself. This allows Iguana Core (running at the heart of the smart chain) to identify where its most recent notarization can be found. The notarization
process cycles every ten minutes, assuming the smart chain’s network is consistently
active. If the network has periods of inactivity, the notary nodes halt the process (to
save against unnecessary notarization costs) and reactivate as soon as new transaction
activity appears on the smart chain’s network.

There is also a difference in the number of notary nodes required to notarize an
smart chain as compared to the KMD main chain. Whereas with the KMD main chain
13 notary nodes are required, only 11 notary nodes are required to notarize an smart
chain. This difference is based on the underlying math that ensures that the number
of smart chains in the Komodo ecosystem can scale into the tens of thousands.

(We invite the reader to consider the fact as each smart chain can support thousands
of transactions per minute, this makes the combined ecosystem capable of supporting millions of transactions per minute. This includes cross-blockchain interoperability, via our atomic-swap powered technology, as explained in [Part III](/historical/whitepaper/chapter6/). This makes
Komodo among the most scalable of financial-technology solutions in existence, and
capable of competing with the transaction volumes of fiat networks.)

Naturally, as each level of notarization takes time to perform, there is an additional
delay for smart chains as compared to the KMD main chain. An smart chain’s history
is notarized into the KMD main chain approximately every ten minutes, assuming
constant activity. This notarization will then be pushed through the notarization process into the chosen PoW network (Bitcoin). We estimate that a transaction performed
on an smart chain will receive the KMD main chain’s protection within approximately
ten minutes, and the Bitcoin hash rate’s protection in approximately twenty to thirty
minutes.

Another difference between the KMD main chain and an smart chain is that the
notary nodes only mine the KMD main chain. Smart-chain developers are responsible
to create any required network of miners to process the smart chain’s transactions.
This does not need to be a full network of mining farms, such as those in Bitcoin.
Rather, it only needs to be enough computing power to process transactions, and
to provide any desired level of hash-rate security to cover the ten-minute waiting
period. For a smallbusiness with intermittent periods of transaction activity, a single,
dedicated, full-time server may be enough. Larger businesses can scale as desired and
can also work to attract a network of freelance miners.

It is also possible that a network of freelance miners will naturally arise within the
Komodo ecosystem, to observe and manage transaction-processing services wherever
and whenever they are required, through automation.

This setup dramatically reduces the overhead costs and effort the entrepreneur and
developer would otherwise have to allocate to a network of high-hash rate miners.
These freed resources of the entrepreneur and developer can therefore be allocated to
other uses in their business models.

The total yearly cost for the Komodo notary nodes to notarize the KMD main chain
into the currently chosen PoW chain, Bitcoin, is approximately \~180 BTC/year (a
value of \~$1.5M USD at the time of the writing of this paper). Funding for the notary nodes to perform this service was raised during the Komodo ICO, and current BTC holdings give us many years to come before we will be required to implement any business models to replenish our BTC funds.

On the other hand, the total cost for the smart chain developer to notarize their independent chain into the KMD main chain is but a fraction of the cost. This security mechanism is not limited to smart chains created within the Komodo ecosystem. In fact, Komodo’s Blockchain Security Services are available to any existing blockchain. With Komodo, any blockchain can be protected with the power of the Bitcoin hashrate for a tiny percentage of the cost. We have not yet finalized the details, so please contact the Komodo Platform team at [marketing@komodoplatform.com](mailto:marketing@komodoplatform.com) for more information.

Thus, an entrepreneur in our ecosystem can have their own independent blockchain
that is backed up by the hash rate of the Bitcoin mining network, at only a fraction of
the cost. In the following section, [Part II](/historical/whitepaper/chapter5/), we begin our discussion of an entrepreneur’s
formation and distribution of a Komodo smart chain. In [Part III](/historical/whitepaper/chapter6/), we discuss in detail
our method of distribution and trading, using our atomic-swap technology. [Part IV](/historical/whitepaper/chapter7/)
discusses how with each of these components, users have the option of zero-knowledge privacy. In [Part V](/historical/whitepaper/chapter8/), we mention our smart-contract technology (our current development focus).
export const title = "Whitepaper: Chapter-4";
export const description =
  "Introducing Komodo's decentralized initial coin offering (dICO) solution, revolutionizing the ICO process with increased security, fairness, and privacy.";

# Abstract of the Decentralized Initial Coin Offering

There lies a great power in the idea that any person, regardless of nationality, creed,
or background, can obtain funding to innovate and prosper. An integral tenet of
blockchain technology is "decentralization." By decentralizing systems, we reduce
the number of control points that can be compromised and manipulated. Decentral-
ization plays a more common role in our new cryptocurrency economy, but there is
one area of the market that remains centralized and vulnerable: the initial coin offering (ICO). The cryptocurrency industry needs a solution, and Komodo presents an
answer with our decentralized initial coin offering (dICO).

In today’s common ICO model, the high level of centralization creates many problems. Third-parties can block or manipulate entrepreneurs’ efforts to innovate and
prosper. The centralized location of releasing the ICO blockchain product is vulnerable, allowing whales, hackers, and human error to corrupt or destroy an entrepreneur’s efforts. The negative experience of users in these situations can also
impact the perception and adoption of cryptocurrency. Furthermore, the traceable
nature of an ICO prevents society from crowdsourcing and purchasing within our
inherent right to barter in private.

The dICO model, as created by the Komodo project, overcomes these challenges. It
provides the necessary technology to create and release a blockchain product to the
world with the full power of decentralization.

Entrepreneurs building on our platform begin by creating an smart chain, and our
technology simplifies this process. One need only install the necessary software, execute a few commands on a command prompt, and then establish a connection between two or more Komodo-enabled devices. Komodo’s core technology will do the
rest of the work necessary to create a fully independent blockchain, empowered with
an array of Komodo features.

Our dPoW technology is a key feature, as explained in [Part I](/historical/whitepaper/chapter1/). dPoW provides
the necessary security to protect the integrity of the blockchain. Use of dPoW is
optional, and since smart chains in the Komodo ecosystem are independent by nature,
entrepreneurs can discontinue dPoW services at will.

Having thus created the blockchain, the entrepreneur then uses our decentralized
exchange to release the project to the world in a decentralized manner. Our decentralized exchange is called, BarterDEX, and it is thoroughly explained in [Part III](/historical/whitepaper/chapter6/) of this paper. Because BarterDEX is a decentralized exchange, and through our atomic-swap
technology (also explained in [Part III](/historical/whitepaper/chapter6/)), no third-party manipulators can prevent the
entrepreneur from their crowdsourcing and innovative endeavors.

Through our privacy technology, Jumblr, dICO participants can purchase the product within their inherent right to barter in private. A detailed explanation of Jumblr and its method of providing privacy is provided in [Part IV](/historical/whitepaper/chapter7/) of this paper.

## The Challenges in Current ICO Platforms

### Specific Weaknesses in the Centralized ICO Model

There are many weaknesses present in today’s Initial Coin Offering (ICO) process.
Several notable weaknesses include third-party discrimination, "whale" manipulation,
the vulnerability to theft and human error, and a lack of privacy.

#### Third-Party Discrimination

An entrepreneur seeking to serve their intended audience may experience adverse
intervention from a third party. The antagonists may display personal and malicious
intent, regardless of the value of the entrepreneur’s innovation.

#### Centralization of Technology: "Whale" Manipulation, Theft, and Human Error

During the initial stages of a blockchain’s release to the public, users who are
wealthy and tech-savvy (often referred to as "whales") have an unequal advantage:
they can rapidly purchase a majority of the coin supply while it is inexpensive. There-after, they can manipulate the market price at the expense of less established ICO
participants.

Furthermore, today’s ICOs are generally conducted in escrow, where the purchasers
must transfer money to one node for holding. This typically occurs through a single
website, and the cryptocurrency funds are held on a single server. They must then
wait while the ICO administrators first verify the transactions and distribute the coins.
During this time the funding is centralized, and therefore vulnerable to thieves and
human error.

#### Lack of Privacy

Because ICO transactions are highly traceable it is difficult, if not impossible, to
perform ICOs within our right to barter in private.

### Third-Party Discrimination via the Centralized ICO

One weakness of the ICO process is, paradoxically, rooted in a great strength of
blockchain technology: its borderless nature. A key power of any blockchain is that
any human capable of accessing the technology can activate the blockchain, regardless of their geographical location or social status. Thus, anyone can provide yet another verifiable record of the transaction history, and this decentralization provides a
crucial element of security to the blockchain.

An ICO innovator, therefore, may prefer to use a blockchain platform that transcends man-made barriers, to protect their innovation. Circumventing man-made
barriers could be integral to the blockchain’s survival, because the element of decentralization prevents malicious actors from creating subjective borders around the
blockchain records and then using authority to falsify and manipulate.

This creates a conundrum, however. As a human race, we also find strength and
empowerment in subjectively defining our own demographics for various reasons,
whether they be to form companies, cultures, communities, etc. While we find the
ability to create subjective demographics useful, it contrasts with the borderless nature of blockchain technology. Members of one demographic may desire to participate
in a specific ICO, but another demographic may find this unfavorable. Therefore, the
second party might try to forestall progress. The paradox lies in the fact that for the
underlying blockchain product to maintain its integrity, it must serve both communities without regard to any man- made barrier between them.

The problem compounds even further as we observe that on a decentralized
blockchain platform, a new ICO product is capable of functioning anywhere there
is access to the underlying technology. Therefore, on a decentralized platform, once a
new blockchain product is released any person from either demographic is now able
to utilize it regardless of the overall sentiment of either demographic. The problem
becomes most pronounced if members of a competing group attempt to even maliciously prevent an innovation out of selfish reasons. Thus, it is imperative that the
innovator have the option of protection against would-be malicious competitors.

The overall centralized nature of today’s ICO process, therefore, presents a problem.
Entrepreneurs who are not able to navigate the adverse effects of an inhibiting third
party may be unable to realize their creative potential.

### Centralization of ICO Technology: Whales, Hackers, and Human Error

Yet another issue plaguing ICOs is that the technology upon which an ICO is
released is also centralized. This presents a vulnerability to human foibles.

#### The Manipulative Behavior of Whales

The centralization of the point of purchase creates an unequal playing field in favor
of wealthy, tech- savvy users (referred to as "whales" in the cryptocurrency community). To understand this problem, one must comprehend that "nodes" (computer
devices which compute the buying and selling of cryptocurrencies) take orders from
ICO purchasers one-by-one. Presently, ICOs are released on only one node — for example, the purchase could take place through a single website, wherein the gathered
funds are held on a single server.

Because the node can only process one transaction at a time, the person whose
order arrives first will receive an advantage over the coin’s future value. If the initial
purchaser is both wealthy and able to program sophisticated "bots" (custom-designed
programs that automate the trading of cryptocurrencies), the whale can buy a controlling interest in the supply before less wealthy or less technologically savvy people
have a chance to participate.

In our current market, often the people who would most benefit from an ICO are
unable to participate before the supply evaporates. Meanwhile, this whale now has
sufficient control on the overall supply to act as a centralized market manipulator.
Buying and selling in large quantities forces fluctuations in the whale’s favor.

#### Hackers and Human Error

Because all coins of an ICO typically process through one node during the pur-
chasing period, the entire supply is vulnerable to any person with access to the node.
Therefore, both malicious and clumsy human agents can destroy an ICO. The data
holding the cryptocurrency can be damaged, stolen, or simply lost through incompetence.

An entrepreneur can also consider that in today’s ICO model both the funding
provided by the purchasers, as well as the actual ICO coins that the entrepreneur
intends to sell, remain on the centralized node for a long period of time. It is not just
one side of the crowdsourcing endeavor that is at risk, but both.

This central point of failure can be catastrophic for all participants.

#### The Right to Barter in Private

Finally, the lack of current privacy options in the ICO process inhibits blockchain
participants from purchasing within our right to barter in private. This right to privately exchange goods and servicesextends further into history than the written word.
We have, as a species, utilized this right to organize into communities, institutions,
and even nations.

Many of humanity’s most meaningful advancements in art, technology, and other
human endeavors began in situations where the creator had the security of privacy
in which to explore, to discover, to make mistakes, and to learn thereby.

The right to barter in private, however, is under modern threat as the recent monumental and historical phenomenon, "The Internet of Information," permits many
kinds of people to quietly and without inhibition; monitor other people’s shopping
and bartering behavior. This is a dangerous development, as it destroys the privacy that empowers much of humanity’s personal growth. We must reserve our right to
barter in private, for we observe that there are myriad ways in which a common
person may explore personal growth in an economic environment.

Yet, the highly traceable nature of today’s centralized ICO model is in direct contradiction to this human need.

## The Blockchain Industry Needs a Solution, and Komodo Presents an Answer

Together, these issues show that the current state of the ICO market is plagued
with limitations that inhibit freedom, security, entrepreneurship, and even human
growth. The cryptocurrency industry needs a solution to these problems, and Komodo presents an answer.
export const title = "Whitepaper: Chapter-5";
export const description = "Komodo's dICO revolutionizes ICOs, enabling secure and fair release of blockchain products through a decentralized exchange.";

# The Komodo Solution

## The Decentralized Initial Coin Offering

The Komodo ecosystem presents a solution, the decentralized the initial coin offering (dICO), that solves these issues and even adds new possibilities to the cryptocurrency market. The decentralized nature of the dICO enables the entrepreneur to
release a blockchain product beyond the reach of a malicious third-party influencer.
Furthermore, through our decentralized exchange, BarterDEX, the dICO allows an
entrepreneur to release their product in a manner that mitigates and even eliminates
many of the issues regarding whales, hackers, and human error. With the advantage
of Komodo’s privacy technology, Jumblr, the participants in a dICO are empowered
with their right to barter in private.

Our decentralized exchange, BarterDEX, is explained in detail in [Part III](/historical/whitepaper/chapter6/). An indepth discussion of our privacy technology, Jumblr, is provided in [Part IV](/historical/whitepaper/chapter7/).

## The Process of Creating a New Blockchain in the Komodo Ecosystem

Formerly, coding and generating the blockchain itself were a most difficult aspect
of the development process. Now, the Komodo team has simplified the process into
easy steps. Through Komodo’s Iguana Core technology (introduced in Part I), the
entrepreneur can create a new independent blockchain by entering just two simple
commands in the command prompt of their computer.

The following steps rely on one of Komodo’s underlying software processes that
run in the background on a user’s computer. The name of this software is the "Komodo daemon," or `komodod`, for short. `komodod` is rooted in Iguana Core technology.

### The First Command to Create a New Coin

```bash
./komodod -ac_name=[ENTREPRENEUR'S COIN] -ac_supply=[TOTAL COIN SUPPLY] -gen
```

The first part of the command, `./komodod`, initiates a new instance of Komodod.

By default, the initial `./komodod` command executed alone would launch the
Komodo main chain, KMD, on the user’s computer. However, the next part of the
command tells Komodod to behave differently.

```bash
-ac_name=[ENTREPRENEUR'S COIN]
```

This command tells Komodod to look for a coin with the inserted name.

```bash
-ac_supply=[TOTAL COIN SUPPLY]
```

This tells Komodod how many total coins there should be in this chain.

```bash
-gen
```

This tells Komodod that the user desires to mine this network.

The underlying code of Iguana Core can now make several decisions. First, it will check its connection to the Komodo ecosystem to see if there is a coin by the name of \*ENTREPRENEUR’S COIN+, having a coin supply of \[TOTAL COIN SUPPLY]. If the coin name and total supply are not found, Komodod will assume that the user is attempting to create a new coin, and the \[-gen] command tells Komodod that the user wants to mine it.

Komodod now begins the automated process of creating a new smart chain in the Komodo ecosystem. Komodod will first make a fresh and empty clone of the KMD main chain (though it will not yet generate the actual coins), with only a few differences to the underlying nature of the chain.

### The Features of the New Smart Chain

There are several primary differences between an smart chain and the main Komodo
chain. For example, the smart chain will not automatically generate 5.1% rewards for
all wallet addresses holding coins, unlike the main chain. Furthermore, the smart
chain’s dPoW consensus mechanism is built to notarize to the KMD main chain (as
explained in [Part I](/historical/whitepaper/chapter1/)).

Some of the differences reveal strong advantages held by members of the Komodo
ecosystem. By design, this smart chain is capable of automatically adopting any updates that the Komodo core development team add to the framework. The smart chain
also has a built-in capacity within the framework to allow the entrepreneur to code
new rules.

For example, the entrepreneur may decide not to use a PoW consensus mechanism,
but may instead prefer PoS (discussed in [Part I](/historical/whitepaper/chapter1/). Other changes can also be made, according to the entrepreneur’s imagination and developer knowledge. So long as
the new code that the entrepreneur adds to the smart chain does not interfere with
the overall framework, the smart chain will smoothly integrate with the rest of the Komodo ecosystem. We provide more details on this topic in [Part V](/historical/whitepaper/chapter8/)’s section regarding
smart contracts.

For the purposes of our discussion, this new smart chain is otherwise the same as
the Komodo main chain, including the features to communicate natively with other
blockchains via BarterDEX. The reader may note that this new Komodo smart chain
is not a colored-token running on top of a parent blockchain, as is often the case in
other blockchain ecosystems (consider the ERC20 token of the Ethereum platform).
Instead, this smart chain is an entirely unique and independent blockchain unto itself.

This empowers the entrepreneur with significant advantages over other blockchain
ecosystems. The smart chain can run on its own nodes, act according to whatever
rules the entrepreneur can imagine, and can scale according to its own audience.
Should an smart chain in the Komodo network experience a sudden explosion of
activity, the sudden change will not negatively impact the overall Komodo ecosystem.
This independence grants a significant competitive advantage in the form of overall
security, speed, and ease of use.

Consider the advantage of developing an entrepreneurial product as a fully independent blockchain. Should the entrepreneur desire at a future point to leave the
Komodo ecosystem for any reason, they are free to take their blockchain product
with them.

### Generating and Mining the New Coins

Let us return now to the moment after the entrepreneur executes the first command in the command prompt, and Komodod creates a fresh and empty clone of
the Komodo main chain. While the instance of the Komodod program (running on
the entrepreneur’s local computer device) will create the necessary code for the new
smart chain, Komodod will not yet generate the coin supply itself. Komodod instead
will wait for the next few steps to occur.

The reason for the wait is that a blockchain’s essence depends upon existing not
in isolation, but in a network of multiple devices connected. This is the nature of
decentralization. Komodod will wait until it receives a signal from another device,
thus indicating that it has a peer with which to form the smart-chain network.

#### The Entire Coin Supply is Distributed in the Genesis Block

It is imperative to note that in the Komodod process, the entire coin supply is
created and distributed immediately to the device that mines the first block, the Genesis Block. The code performs this distribution as a one-time reward for discovering the first valid block hash (as explained in [Part I](/historical/whitepaper/chapter1/)). Due to the sensitive nature of this
step, we recommend that the entrepreneur use a Virtual Private Server (VPS) service.
This allows two secure devices to connect to each other with little, if any, risk of a
third-party actor mining the first block (which would thus enable a would-be thief to
acquire the entire coin supply before distribution).

Having established a secure connection with a second device, the entrepreneur will
enter the following command on the second device.

```bash
./komodod -ac_name=[ENTREPRENUER'S COIN] -ac_supply=[TOTAL COIN SUPPLY] -addnode=[INSERT IP ADDRESS OF FIRST DEVICE]
```

Note that the first three elements of the command, \[./komodod], \[-ac\_name], and
\[-ac\_supply], are the same. It is important that the parameters inserted into these commands match exactly. Otherwise, the instances of Komodod running on the separate devices will ignore each other, and the coin will not be mined.

In the second VPS, the \[-gen] command is not present. In this circumstance, we are assuming that the entrepreneur wants to capture the entire coin supply on the first device. Technically speaking, assuming the entrepreneur has ownership over both devices, it does not matter if both devices initiate the \[-gen] command. Both devices will attempt to mine the first block and the superior device will receive the coin supply.

There is another key difference in the command.

```bash
-addnode=[INSERT IP ADDRESS OF FIRST DEVICE]
```

An "IP address" can be compared to a human being’s home mailing address, where
the IP address is designed for computers to be able to geographically find each other.

With the execution of the IP address command, the second device knows to look
across the available connection (the Internet, VPS service, etc.) for the first device,
which is already running an instance of Komodod and the new coin. The command
here simply tells the computer the proper IP address of the first device.

As soon as these two devices connect, having all the proper Komodod software
running and set in place, the mining begins. One of the devices will mine the first
block and instantly receive the total coin supply of the entire blockchain into the
user’s chosen wallet.

Both devices sync this information to each other, and the \*ENTREPRENEUR’S COIN+ now exists in the world. The entrepreneur can also add more and more devices to the network.

### Notarizing to the Komodo Main Chain

To receive the security of the dPoW consensus mechanism, the entrepreneur simply needs to have the elected notary nodes add the \*ENTREPENEUR’S COIN+ to their internal list of coins to notarize. This will empower the entrepreneur’s product with the same verifiable and decentralized security of the Komodo parent chain.

The process of adding a new notarization service can be executed by the notary
nodes with just a simple command. While we are at this early stage of development,
this sign-up process for new dICO products is not yet automated. In the future, we
intend to automate as much of this process as possible.

There is a fee for receiving notarization services. This helps to cover the business
costs associated with notarization (recall that all notarizations are financial transactions, by nature).

We already have over fifteen partners successfully notarizing to the Komodo main
chain. We are actively seeking more partners, and we encourage the reader to reach
out to our team directly with inquiries.

Entrepreneurs are thus able to use the smart chain’s native dPoW consensus mechanism to notarize to the Komodo main chain to create a secure backup of the coin’s history. Even in the event of an attack at this early state of existence the entrepreneur can
rest assured that their product will survive, so long as one copy of the blockchain’s
history exists.

Everything is set on the backend for the entrepreneur, and they are now fully prepared to begin the dICO process. Naturally, we understand that for many potential
entrepreneurs in the Komodo ecosystem, this process is unfamiliar territory. We encourage interested entrepreneurs to reach out to our team for guidance during development.

## The Distribution of Coins

### The Trials and Travails of the Centralized ICO Method

Previously, the entrepreneur at this point would have been required to go through
a centralized ICO process.

This could have required several cumbersome and possibly dangerous steps. For
example, the entrepreneur would begin gathering cryptocurrencies from their audience to personally hold in escrow while the process of matching purchases to the new
blockchain coin were verified.

To distribute these coins, the entrepreneur had two primary options. They could
have created and distributed a digital software wallet capable of holding the entrepreneur’s coins. This would requiretheir audience to download the software. The
entrepreneur would then have to send all the appropriate coins to each wallet address,
according to the process they established during their ICO.

Or, the entrepreneur would have to make formal arrangements with another service
to manage this process, such as with a centralized exchange. This would require a successful negotiation with this third party, likely paying fees as a part of the agreement.

The entrepreneur would then be required to act within the centralized exchange’s
arbitrary framework.

The centralized ICO process can be arduous and, at times, disastrous.

### Enter the dICO

#### Powered by Komodo’s BarterDEX & Jumblr Technology

The Komodo dICO model is an extension of Komodo’s BarterDEX technology.
BarterDEX is an atomic- swap powered, decentralized exchange. It enables users to
directly exchange cryptocurrencies from one person to another without third-party
involvement (i.e. no centralized exchanges, escrow services, vouchers, etc.). Furthermore, as the dICO model is entirely decentralized, anyone can use it at will. There are
no centralized authority figures capable of creating artificial control points that can
be manipulated at the expense of the users. Please turn to [Part III](/historical/whitepaper/chapter6/) for more details.

To begin the distribution process, the entrepreneur first chooses how many nodes
they would like to use for the distribution. Nodes can be any type of machine capable
of connecting to BarterDEX. Typically, a small-business entrepreneur may choose to
use server machines. Server capacity can be rented online, and the servers can be
distributed geographically throughout the world, if desired.

While renting a multiplicity of servers may be the method of choice for an estab-
lished small-business, it is not a requirement. An owner of an even smaller business,
operating on a low budget, can simply use their own computer(s), geographically
stationed nearby for convenience. On the other hand, a large corporation could use
the server capacity they already own. The number and strength of the machines is a
choice made by the entrepreneur.

Having decided the method of distribution, the entrepreneur will then prepare the
total supply of coins. (We are assuming the coins are still located on the first device
that mined the entrepreneur’s genesis block.) The entrepreneur will first break down
the total collection of coins into smaller digital pouches. These small bags of coins
are ultimately what will be traded on BarterDEX with their audience. The size of
the bags is chosen by the entrepreneur, and therefore the entrepreneur can choose a
size that is agreeable to their outlook on any KYC legal requirements. For a detailed
explanation of the process of breaking down the total collection into smaller bags of
coins, we also recommend reading about UTXO technology in [Part III](/historical/whitepaper/chapter6/) of this paper.

Having created these bags of coins, the entrepreneur then sends them to all chosen nodes throughout the BarterDEX network. Coins are distributed to each node’s
wallet(s) by a normal transaction.
With the coins distributed as desired, the entrepreneur sets the time and date when
each bag of coins will be available for purchase. When a bag of coins becomes available on BarterDEX for trading, members of the Komodo ecosystem simply purchase the coins. Please see our discussion on atomic- swap technology in [Part III](/historical/whitepaper/chapter6/) for more
details.

#### The Many Solutions of the dICO Model: Security, Privacy, Decentralization, and Freedom

This method of conducting a decentralized initial coin offering mitigates and cir-
cumvents the issues found in a centralized ICO. The entire process is conducted in a
decentralized manner. The dICO entrepreneur has direct access to their audience, as
there are no centralized human authorities acting as middlemen.

Because the bags of coins can be distributed across a vast range of nodes, and because the entrepreneur can program the time at which each bag of coins becomes
available, it is possible to prevent a "whale" from seizing a majority control in one
swooping moment of the dICO. The whale will have to compete to purchase their desired amount one transaction at a time, just like the other members of the ecosystem.

Furthermore, BarterDEX has advanced trading features that provide additional
whale resistance. For example, BarterDEX can perform ten to twenty trades at once,
unlike a normal node in the typical ICO model. Therefore, even if the whale were able
to place large orders on every node of a dICO, BarterDEX would still be performing
orders simultaneously for other members of the Komodo ecosystem.

Concerning theft, the dICO provides solutions to both methods of theft in the centralized ICO. Unlike the centralized ICO, once the distribution of the bags takes place the effect of their distribution adds a layer of security from a would-be hacker. The hacker can only steal funds at the node they manage to penetrate. Were the hacker to steal coins before the actual dICO, the entrepreneur would have the option to simply create a \*NEW ENTREPRENEUR’S COIN+ again, without losing any personal wealth.

Furthermore, since the trades happen instantaneously with each bag available for sale, the entrepreneur is only in possession of either their own \*ENTREPRENEUR’S COIN+, or the cryptocurrency funds provided by the dICO participants—but not both. The entrepreneur is never at risk of losing both their own funds and the funds of their audience, which is a strong advantage over today’s ICO model.

Regarding human error, should one of the node’s databases be corrupted by accident or hardware failure, only one node’s coin supply is lost.

Since the coins are immediately available on the BarterDEX exchange for trading,
the entrepreneur’s audience has an immediate trading market. This stands in contrast
to today’s ICO model, where users often wait weeks or even months before liquidity
for their ICO product arises in a centralized exchange.

Finally, through Jumblr technology, participants have the option of privacy when
purchasing the dICO product. This enables them to support the crowdsourcing efforts
of the entrepreneur within their inherent right to barter in private.

Upon conclusion of the distribution of the dICO coin supply the entrepreneur
has successfully and immediately completed all the crowdsourcing-related steps that
could have taken months in today’s typical ICO model.

Komodo’s dICO model is significantly easier, freer from manipulation, more flexible, and more secure.
export const title = "Whitepaper: Chapter-6";
export const description = "A decentralized exchange enabling secure and efficient cryptocurrency trading without counterparty risk.";

# Abstract (BarterDEX)

Komodo’s decentralized exchange, BarterDEX, allows people to trade cryptocurrency coins without a counterparty risk. The protocol is open-source and trading is available for any coin that any developers choose to connect to BarterDEX. The parent project, Komodo, freely provides BarterDEX technology through open-source philosophy. Our service fully realizes decentralized order matching, trade clearing, and settlement. The order-matching aspect uses a low-level pubkey-to-pubkey messaging protocol, and the final settlement is executed through an atomic cross-chain protocol. Like any exchange, our decentralized alternative requires liquidity, and we provide methods and incentives therein.

## Introduction

The current, most practical method for cryptocurrency exchange requires the use of centralized exchange services. Such centralized solutions require vouchers to perform the exchange. Among many dangers present in this system, end-users are under the constant risk of their assets being stolen either by an inside theft or an outside hack. Furthermore, the operators of centralized exchanges an exhibit bias in how they facilitate trading among their users. They can also create fake levels of volume on their exchange. To eliminate such dangers and limitations requires the creation of a decentralized-exchange alternative.

Among all the centralized exchanges, trading tends to coalesce around a few of the most popular. There is a reason for this behavior. Trading via vouchers is fast; a central exchange can swap internal vouchers instantaneously, whereas trading actual cryptocurrencies through human-to-human coordination requires communication from both parties. It requires waiting for blockchain miners to calculate transaction confirmations.

The speed advantage of a centralized exchange, therefore, creates a compounding effect on the centralization of traders. The faster processing time of vouchers attracts more people: the increased presence of traders creates higher liquidity: with more liquidity, the exchange can feature better prices: the higher quality of prices in turn attracts a larger community, and the cycle repeats. This is a classic Network Effect, and it is the reason that a few centralized exchanges dominate with high-volume trading, while smaller exchanges—both centralized and decentralized—suffer from a lack of liquidity.

### The Beginnings and Travails of Decentralized Exchanges

In 2014 a project called The MultiGateway created one of the first decentralized resources for trading cryptocurrencies. The MultiGateway relied on a separate, though related, blockchain project called the NXT Asset Exchange. The latter facilitated the decentralized exchange of blockchain coins by using proxy tokens (as opposed to vouchers), and these proxy tokens represented external cryptocurrencies (such as Bitcoin).

The underlying technology of this solution is still in use by many blockchain platforms, but the proxy- token protocol is too limited to compete with centralized exchanges. Because trading by the means of proxy tokens requires trading on an actual blockchain, the trading process loses the speed of a centralized exchange. Also, a proxy-token decentralized exchange must still have a storage center to hold the external cryptocurrencies represented by the proxy tokens. At best, this storage center is only distributed, and therefore end-users are under the same counterparty risk that exists in centralized exchanges. Furthermore, the process of trading on proxy-token platforms requires using a set ofgateways (i.e. "The MultiGateway") to convert external native coins (such as Bitcoin) to and from the affiliated proxy tokens. Together, these many problems make the proxy-token method of decentralized trading an impractical solution.

Therefore, a decentralized exchange alternative that seeks to successfully remove the threats and limitations of centralized exchanges must feature the same speed, liquidity, and convenience of a centralized exchange. As of today, no decentralized exchange has successfully replaced any of their centralized counterparts.

### BarterDEX: A Complete Solution

We now present a fully functional, new decentralized technology that makes a competitive decentralized exchange possible. We call our technology BarterDEX, and it allows people to freely and safely exchange cryptocurrency coins from one person to another.

The BarterDEX decentralized exchange creates a competitive method for bartering cryptocurrencies, combining three key components: order matching, trade clearing, and liquidity provision. These components are combined into a single integrated system that allows users to make a request to trade their coins, find a suitable trading partner, and complete the trade using an atomic cross-chain protocol. Additionally, BarterDEX provides a layer of privacy during the order-matching process, enabling two nodes to perform a peer-to-peer atomic swap without any direct IP contact.

The "order matching" component is the process of pairing an end-user’s offer to buy with another end- user’s offer to sell. This component is not the actual trade itself, but is only a digitally created promise between end-users stating that they will perform their parts of the trade.

The order-matching process is achieved by algorithms that define how the orders are paired, and in which order they are fulfilled.

After a successful order-matching execution, the next component is the "clearing" aspect of the trade, wherein end-users must fulfill their promises. This is the process wherein the assets are swapped between the trading parties. BarterDEX facilitates this process and assures the safety of the users therein.

Recall that in previous decentralized exchanges there lies a problem when an exchange has low liquidity. BarterDEX solves this problem by creating Liquidity Provider Nodes (LP nodes). LP’s are trading parties that act as market-makers, buying and selling assets. They provide liquidity to the exchange, and make their profit from the spread between bid and ask orders. LP’s bring price stability to the market, and facilitate end-users in making fast and efficient trades.

### Recent Improvements in BarterDEX

BarterDEX is the result of years of development and iterated versions, with each iteration adding the next layer of required functionality to achieve our eventual goal of large-scale adoption.

BarterDEX holds support for [SPV Electrum-based](https://en.bitcoin.it/wiki/Electrum) coins (removing the need to download a coin’s blockchain), all Bitcoin-protocol based coins running native-coin daemons, Ethereum, and Ethereum- based ERC20 tokens. The BarterDEX API is built to handle the nature of the SPV requirements, providing additional functionality to developers.

BarterDEX also enables a feature known as Liquidity Multiplication, a protocol that allows the same funds to be used in multiple requests on BarterDEX "orderbooks." The first request to fill completes the trade, and all outstanding requests are immediately cancelled. This feature is available to the user when providing liquidity to the exchange (called a "Bob-side" trade); it is not necessary to establish a full LP node to engage in Liquidity Multiplication.

Liquidity Multiplication therefore allows an initial amount of funding to create an exponentially higher amount of liquidity on the exchange. This also provides a special advantage for traders that like to wait for below-market dumps. While this feature is something that any other exchange could implement, few do. On BarterDEX, all orderbook entries are 100% backed by real funds, as opposed to a centralized exchange’s vouchers, which are not as reliable and therefore would present yet another danger for their end-users.

## Barterdex Technology

Before we get into details regarding the nature of atomic swaps, there are several aspects of BarterDEX that are critical to understand.

### Order Matching

The first is the decentralized orderbook. The orderbook is the collection of bids and offers that end- users place on the network. To create our orderbook, BarterDEX creates a custom peer-to-peer network that employs two separate types of nodes: a full-relay node and a non-relay node.

### Order Matching with Full-Relay and Non-Relay Nodes

The difference between a full-relay node and a non-relay node is that the former is typically a high- volume trader who provides liquidity to the network in exchange for being a trading hub on the network. This puts him in the position of being able to complete trades more quickly than his trading competitors. The latter type of node (non-relay) is the more common user, who engages with BarterDEX when trading one cryptocurrency for another, given the user’s daily motivations.

There are no requirements or payments necessary to become either type of node, and so anyone desiring to become a high-volume full-relay node will find no restrictions. To be successful as a full-relay node, however, one must be able to carry out transactions on the network with a competitive Internet connection and high-capacity bandwidth.

There are several incentives encouraging users to become full-relay nodes, as these types of nodes are necessary to build the backbone of the BarterDEX network. One incentive to run a full-relay node is that by being at the center of a wide network of non-relay nodes, the full-relay node has better connectivity and thus a higher chance of being the first to complete a trade.

A non-relay node has all the same available trading options—including the option to be liquidity providers, and thus use liquidity multiplication. Non-relay nodes are only limited, naturally, in terms of the total number of connections they maintain to other users. We expect that most nodes joining the network will be non-relay nodes.

In theory, roughly 100 full-relay nodes should be able to support thousands (if not tens of thousands) of non-relay nodes, thus providing a large and high-volume network. We are in the process of achievingreal-world implementation. As of the writing of this white paper, the public Komodo community has performed almost 100,000 atomic-swap trades on BarterDEX.

When limitations do arise in the scaling process, we have various contingencies in place, one of which is the creation of clusters. It is possible to create clusters of BarterDEX nodes that are separate from other clusters on the network. To achieve this, when one cluster approaches a level of user load that is overcapacity, users can opt to seed a new cluster by creating an independent set of seed nodes. This feature amplifies the scalability of the BarterDEX network, as it allows clusters of users to form in accordance with user desires. We assume that at large scales there will be sufficient inventory in the orderbooks for clusters to provide ample asset liquidity, especially if the act of partitioning into a new cluster is based on trading a coin that is overcrowded.

Furthermore, as we continue to develop this new technology, we may also create a protocol that will allow these separate clusters to share their order boards via bridge nodes, which in theory can act to cross-pollinate desired orders from one cluster to another.

To optimize the network load, we minimize the hierarchical transmission of the orderbooks and the fetching of data. There are also several different methods of obtaining data by which we can maximize the number of nodes that can fully connect to the BarterDEX network.

### Jumblr Technology Adds Privacy

While BarterDEX does not require non-relaying nodes to publicly share their IP addresses, it is important to note that BarterDEX itself is not private. Instead, we use Jumblr, an accompanying Komodo technology, to provide privacy options.

Users should assume that if privacy is important for their given trading activity, they need to employ Komodo’s additional privacy technology, Jumblr. On the surface, non-relaying nodes perform addressing via a `<curve25519>` pubkey, and the IP address of one non-relaying node is normally not directly shared with their accompanying non-relaying trading partner. However, full-relay nodes are capable of monitoring IP addresses at the lower levels of the network, and therefore a malicious actor would be able to link IP addresses of non-relay nodes to pubkeys, thus uncovering the most crucial aspects of their privacy.

### Iguana Core Provides the Foundation for Our "Smart Address" Feature

BarterDEX itself is a fork of one our earliest codebase experiments, Iguana Core, which we briefly encounter in each part of this paper. All BarterDEX transactions that use the atomic-swap protocol are created and signed in a format that is managed
by the Iguana Core codebase. This enables a powerful combination of features.

The following page is a high-level discussion of one method that Iguana Core supports the fluidity of the Komodo ecosystem. Newcomers to the cryptocurrency industry and those who are not familiar with developer language may find this section too challenging to understand. We welcome the reader to simply read the two warnings below, and then to skip to the next section.

*   Some of the features that Iguana Core enables are highly advanced, and therefore users interacting with BarterDEX and other Iguana-compatible GUI software applications should always perform proper research and exercise caution.
*   The important thing for users to understand is that they should be careful not to spend the same funding in two different standalone apps. In other words, if they are trading with funds in a BarterDEX GUI, they should not also try to spend those funds in their Agama Wallet (or another Iguana- compatible wallet). Instead, they should wait for both apps to be in sync before moving forward.

One specific feature is a specialty wallet that can manage and trade among a multiplicity of different blockchain coins. To explain the significance of this multi-coin wallet feature, let us observe how a standalone GUI app formerly interacted with cryptocurrencies.

Previously, for a GUI software application to manage cryptocurrencies, the soft- ware application usually required the creation of a wallet.dat file, which is locally stored on the user’s computer. This wallet.dat file held the privkeys—passwords that unlock funds on a blockchain—and other encryption-enabled protocols necessary for the user to manage funds. There are many limitations in the wallet.dat method. For instance, typically only one software application should access the wallet.dat file at a time, to prevent data conflict and corruption.

The Iguana Core codebase enables the user to interact with their funds on the blockchain(s) without requiring a wallet.dat file. Because the Iguana Core codebase works with raw transaction data, the codebase allows a user to first create and then manage a public blockchain "smart address" that can be accessed from anywhere, by any compatible standalone GUI, simply with a passphrase that unlocks their privkey.

To maintain control over their funds without requiring a wallet.dat file, users need only create a smart address and then retain a copy of the accompanying passphrase (typically a collection of 12 to 24 common dictionary words arranged in a specific order) that is provided at the moment of creation. By entering this passphrase into an Iguana Core compatible standalone GUI app, Iguana Core then activates their `<privkey>`, which then enables users to manage their funds.

Furthermore, the smart address created by Iguana Core can manage and maintain multiple types of coins and other blockchain assets. When a user activates any com- patible coin using the Iguana-Core passphrase, Iguana Core can store these coins in a separate address that is compatible with the appropriate blockchain and link this sub-address to the other addresses unlocked by the Iguana-Core passphrase.

Therefore, in the underlying Iguana code, each of the unique coins gets an address that is compatible with its own blockchain, but the Iguana-Core passphrase enables the user to access these coins all at once. Therefore, a BarterDEX GUI app can use this passphrase to enable users to actively trade between a multiplicity of coins.

One key function of the Iguana codebase that makes this possible is the `<withdraw>` command in the Iguana Core API. It is this command that allows individual GUI apps, such as a standalone BarterDEX GUI app, to work with the underlying funds in the user’s addresses. Notice several of the freedoms this provides to the user. All the funds are only spendable by the user with the passphrase. Because there is no need for a wallet.dat file to be stored locally, there is less danger (though users should exercise caution) of data corruption between different standalone software applications that are accessing these funds.

Therefore, an end-user can have a standalone BarterDEX GUI app running on their local machine, which they use to trade, and can also have a separate standalone GUI wallet app that is managing their long- term cryptocurrency holdings.

This also allows standalone GUI applications that are Iguana-Core compatible to support each other. For instance, while a BarterDEX GUI can function without any native-coin daemon process running in the background simply by relying on Iguana Core and public Electrum SPV servers (which remove the need to download blockchain data), the BarterDEX GUI can also work with a native wallet’s coin daemon background process to coordinate blockchain synchronization.

For instance, a Komodo user may run the Komodo Agama wallet, which runs a native Komodo coin daemon (and has a local wallet.dat file), alongside a BarterDEX GUI app. Iguana Core can then enable the BarterDEX GUI to rely on the native coin daemon running in the background of the Komodo Agama wallet, which speeds up the trading process for an end-user, as they do not have to wait for the public Electrum servers to update. The native Komodo coin daemon is the software we encountered in [Part II](/historical/whitepaper/chapter5/), `komodod`.

## The UTXO: an Elusive, Yet Fundamental Concept

BarterDEX relies heavily on a rarely understood technology called the "UTXO," short for Unspent Transaction, which was invented in the original Bitcoin protocol. This technology is fundamental to the operations of any blockchain project that utilizes the original Bitcoin protocol. However, even the most active of cryptocurrency users rarely know what UTXOs are or why they exist.

Because UTXOs play an important part in BarterDEX, and to provide a pleasant user experience, it is essential we adequately explain the UTXO concept. In the future, as the technology surrounding BarterDEX iterates, and as the cryptocurrency community continues to learn, we hope that the concept of UTXOs will be less taxing on a user’s learning curve.

To begin our explanation of UTXOs, let us first examine the language of a common user when describing how much cryptocurrency money they have and how they perceive those funds. We will therefore need to understand the concept of "satoshis," the way a blockchain handles the collection and distribution of funds, and how we utilize these core technologies when trading on BarterDEX.

### Comparing the UTXO to Fiat Money

Let us assume a cryptocurrency user, whom we name Charlie, has $10,000 in his physical wallet. Naturally, when Charlie thinks about the amount of physical (or "fiat") money he has, he says to himself, "I have $10,000."

However, there is no such thing as a $10,000-dollar bill. Instead, Charlie actually has a collection of smaller bills stacked together. For instance, he could have a stack of $100-dollar bills, the total of which equals $10,000 dollars.

If Charlie goes to purchase an item that costs $1, and he only has $100-dollar bills in his wallet, to make his purchase he will take out a single $100-dollar bill and give it to the cashier. The cashier then breaks that $100-dollar bill down into a series of smaller bills. The cost for the item, $1, remains with the cashier, and the cashier then provides change—perhaps in the form of one $50-dollar bill, two $20- dollar bills, one $5-dollar bill, and four $1-dollar bills.

Charlie now thinks to himself, "I have $9,999." Specifically, however, he has ninety- nine $100-dollar bills, a $50-dollar bill, two $20-dollar bills, one $5-dollar bill, and four $1-dollar bills.

We emphasize that not only does he not have ten thousand $1-dollar bills, he also does not have one million pennies ($0.01). Furthermore, because pennies are the small- est divisible unit of value in Charlie’s wallet, we could point out that each bill is a collection of its respective units of pennies. For instance, a $1-dollar bill in Charlie’s wallet we could describe as, "a bill that represents a collection of one hundred pennies and their value."

### Understanding Cryptocurrencies and Their UTXOs

#### A Satoshi is The Smallest Divisible Unit of a Cryptocurrency

Continuing with our explanation of UTXOs, we next need to understand the concept of "satoshis." The name "satoshi" is derived in honor of Satoshi Nakamoto, author of the original Bitcoin white paper. By convention in the cryptocurrency community, one satoshi is equal to one unit of a coin at the smallest divisible level. For instance, 1 satoshi of Bitcoin is equal to 0.00000001 BTC.

Let us suppose now that Charlie has 9.99000999 BTC (Bitcoin) in his digital wallet. Assuming Charlie correctly understands the concept of satoshis, Charlie could say to himself, "I have nine hundred and ninety-nine million, nine hundred and ninety-nine satoshis of bitcoin." This is how Charlie might mentally perceive the collection of money that exists in his digital wallet, like he perceives the $9,999 in his fiat wallet.

#### A UTXO is a Packet of Satoshis, just as a Fiat Dollar Bill is a Packet of Pennies

Recall now that with fiat money, Charlie did not think about how his original $10,000 was comprised of smaller individual $100-dollar bills. Similarly, Charlie also does not think about how his 9.99000999 BTC could be comprised of smaller collections of satoshis.

Furthermore, just as Charlie did not carry around fiat money as a collection of pennies, he also is not carrying around a raft of satoshis. Were he to try to carry a million pennies in his physical wallet, the weight of the wallet would be unmanageable. Similarly, if the Bitcoin protocol were to attempt to manage nine hundred and ninety-nine million, nine-hundred and ninety-nine satoshis, the "data weight" would be so heavy, the Bitcoin protocol would be enormous and unmanageable.

To optimize "data weight," the Bitcoin protocol therefore bundles up the satoshis into something that is like the example of dollar bills earlier, but with one important difference. In fact, here is where the Bitcoin protocol exercises a superiority over fiat money by deviating from the limitations fiat money must obey when bundling smaller values into larger values.

In fiat money, one hundred pennies are bundled into a one-dollar bill, which can then be bundled into a larger bill, and so on. All the sizes of fiat money are preset and predetermined by the issuer of the fiat money when they print their bills and coins.

The Bitcoin protocol, however, does not need to pre-plan the sizes of "bills" (i.e. the collections of satoshis) in the owner’s wallet. Bitcoin is freer in this sense; it can shift and change the sizes of its "bills" at will because there is no need to accommodate for the printing of physical coins and paper.

Instead, the Bitcoin protocol allows for the developer of digital wallets to write code that can optimize how bitcoin satoshis are packaged into "bills," and thus the community of developers can work together to keep the data weight of the blockchain manageable. The better the digital-wallet developer, the more efficient the size of the "bills" (a.k.a. the packets of satoshis).

The Bitcoin protocol does have one limitation, however: It must keep track of how these satoshis are being collected into larger "bills" in everyone’s digital wallets. After all, the very idea of Bitcoin stands in the idea that everything happens under the public eye, where it can be verified. Because the Bitcoin blockchain must keep track of the sizes of these packets of satoshis, the only time the packets can be assembled or disassembled into larger and smaller sizes is at the moment when the user is spending money on the public blockchain. It is at this time that the user is under the public eye, and therefore his actions can be verified.

To compare this limitation to fiat money, consider the effect created were Charlie to cut a $100-dollar bill into smaller pieces. The $100-dollar bill would no longer be respected as a valid form of currency.

As the word, "UTXO," is not a sonorous word, some users in the Komodo ecosystem simply refer to UTXOs as "bills." The concept is effectively the same. However, as the rest of the blockchain industry primarily uses the word "UTXO," we frequently must use this word to maintain a common line of communication. The word UTXO will be used throughout the rest of this white paper, to keep in line with industry practices.

The UTXO packet can be any size, and the developer of the GUI software decides on this process. Most importantly, and to reiterate, a UTXO can only be resized during the process of spending, as this is the moment when the user interacts with the public blockchain.

To further clarify this, let us return to Charlie’s example with fiat money. Recall that when Charlie went to purchase a $1-dollar item, he only had $100-dollar bills in his wallet. He had to give out one $100- dollar bill, and then receive a broken-down collection of dollar bills in return.

This is exactly how it works with UTXOs. Charlie has a collection of UTXOs in his digital wallet. When he goes to buy something, he will give out UTXOs until he surpasses how much he owes, and then the extra change from the last UTXO used will be broken down and returned to him.

For example, let us suppose that Charlie’s 9.99000999 BTC is comprised of three UTXOs worth the following values:

| UTXOs in Charlie’s Wallet | Value          |
| ------------------------- | -------------- |
| UTXO #1:                  | 0.50000000 BTC |
| UTXO #2:                  | 0.49000999 BTC |
| UTXO #3:                  | 9.00000000 BTC |
| Total                     | 9.99000999 BTC |

Charlie now desires to purchase an item that costs 0.60000000 BTC. He will have to hand out enough UTXOs from his wallet until he covers the costs of this transaction, just as he would if he were using fiat money. The Bitcoin protocol calculates the change from the transaction and then returns his change to him.

Remember that there is a fee when spending money on a blockchain. Since we are using Bitcoin in this example, the fee would be paid to cryptocurrency miners. Let us imagine that the fee the miners charge Charlie is 999 satoshis.

We begin by looking at how Charlie would see the process of making the purchase, assuming he does not understand the concept of UTXOs. For now, Charlie only understands how much is in his wallet at the satoshi level as he conducts his transaction:

| Value              | Description                                                       |
| ------------------ | ----------------------------------------------------------------- |
| 9.99000999 BTC     | The amount Charlie initially owns                                 |
| (-) 0.60000000 BTC | The amount Charlie sends to the digital cashier for his purchase  |
| (-) 0.00000999 BTC | The network fee paid to miners                                    |
| ------------------ | ----------------------------------------------------------------- |
| 9.39000000 BTC     | The amount left in his wallet                                     |

This deduction for his purchase all appears very simple to Charlie—a testament to
the Bitcoin protocol’s effective design.

In the background, however, the digital wallet handles the UTXOs and the change process in a manner as determined by the programmer. In Charlie’s example, let us assume that it proceeds this way:

| Value                    | Description                                                              |
| ------------------------ | ------------------------------------------------------------------------ |
| 0.60000999 BTC           | The total amount that Charlie owes to the cashier and network            |
| **(-) 0.50000000 BTC**   | The wallet sends the full value of **UTXO #1** to the digital cashier    |
| ------------------------ | ------------------------------------------------------------------------ |
| 0.10000999 BTC           | This is the remaining total amount that Charlie still owes               |

The wallet now brings out UTXO #2, which is worth 0.49000999 BTC:

This UTXO is broken down or shattered into smaller pieces.

| Value                | Description                                                            |
| -------------------- | ---------------------------------------------------------------------- |
| 0.49000999 BTC       | The size of Charlie’s **UTXO #2**, now in the process of change        |
| (-) 0.10000000 BTC   | This shatter of **UTXO #2** goes to the cashier (payment fulfilled)    |
| (-) 0.00000999 BTC   | This shatter of **UTXO #2** pays the network fee to the miners         |
| -------------------- | ---------------------------------------------------------------------- |
| 0.39000000 BTC       | This last shatter now returns to Charlie’s wallet as a new UTXO        |

Charlie now has one new UTXO in his wallet, and it is worth 0.39000000 BTC:

| Charlie’s New Wallet State   | Value            |
| ---------------------------- | ---------------- |
| UTXO #3:                     | 9.00000000 BTC   |
| UTXO #4:                     | 0.39000000 BTC   |
| ---------------------------- | ---------------- |
| Total                        | 9.39000000 BTC   |

If Charlie wants to buy something later, these UTXOs will have to be broken up once more, according to the costs and programming of the digital wallet. Again, whatever is left over from his last UTXO comes back to his own wallet as a new UTXO.

Now let us suppose that Charlie receives 0.4 BTC from someone else. In Charlie’s wallet, he will see a total of 9.79 BTC. However, in his wallet there are now actually three UTXOs:

| Charlie’s New Wallet State | Value          |
| -------------------------- | -------------- |
| UTXO #3:                   | 9.00000000 BTC |
| UTXO #4:                   | 0.39000000 BTC |
| UTXO #5:                   | 0.4000000 BTC  |
| Total                      | 9.79000000 BTC |

As a result, the number and sizes of UTXOs in Charlie’s wallet will vary over time. He may have many smaller UTXOs that make up his full balance, or sometimes he might just have one large UTXO that comprises all of it. For Charlie, it is normally possible to ignore this since the wallet developer could handle everything automatically.

However, understanding the nature of BarterDEX currently encourages users to understand UTXOs, as the process relies on their UTXO inventory during trading, as explained below.

## Trading on Barterdex

From our point of view as developers, the most difficult aspect of creating BarterDEX was in matching the inventory of UTXOs between trading partners.

To illustrate this complexity, let us briefly return to the example of Charlie and fiat currency. Let us suppose that Charlie has only a $50-dollar bill in his wallet and wants to spend $35 dollars at a videoarcade. He needs to trade $35 for the equivalent number of video-game tokens. However, he can only work with the bill that is in his wallet to trade for the tokens.

In a typical arcade, this process is simple. There are just two currencies—his dollars and the video game tokens—and he will have a human cashier available to manage the trade. He gives the $50-dollar bill to the human cashier, and the cashier returns $15 dollars in dollar bills, and $35 dollars’ worth of video-game tokens.

In creating BarterDEX, however, our goal is to decentralize all points of control. (The "cashier," in this sense, is a centralized authority who could be corrupted or could commit human error). That means that we cannot have a human cashier present in BarterDEX to trade Charlie’s three UTXOs into their appropriate sizes when he wants to swap for other currencies.

A further challenge lies in the number of currencies. For BarterDEX there are not just two coins, but many coins, with myriad users, each having a variety of unique UTXO sizes in their wallets. In addition, the trading happens in real-time, through automation, on a decentralized peer-to-peer network, supporting a countless number of separate blockchain projects, while providing a speed and (eventually) liquidity comparable to that of a centralized exchange. All of this must be accomplished while maintaining a level of security and safety that only decentralization can provide.

Finally, imagine if there were no cashier to break down Charlie’s $50-dollar bill. What if instead, he had to approach other arcade customers to barter for their tokens? This would create a difficult scenario for Charlie.

In its current iteration (continuing the use of the $50-dollar metaphor as applied to UTXOs), we limit BarterDEX’s capability to only perform a trade for Charlie’s $50-dollar bill in exchange for the currency that another customer holds. BarterDEX does not provide a service whereby Charlie can break down his $50-dollar bill into a convenient set of $10-dollar and $5-dollar bills for trading. He must give up his full $50-dollar bill for whatever he wants in return.

The process of breaking down UTXO inventory, therefore, is both in the hands of the user and in those of the developers creating the standalone GUI apps. We are working with our community to simplify this process. Naturally, it is complex and will take time. Therefore, we recommend that users who engage with BarterDEX have a basic understanding of their UTXO inventory and how they are bartering with other users before using it.

### How BarterDEX Deals with Order Offers and UTXOs

When a BarterDEX user offers a trade to the network, the BarterDEX protocol itself does not prioritize the total number of satoshis that the user offers. Instead, BarterDEX simply looks through the user’s inventory for the largest-sized UTXO that is below the amount the user offered.

For example, let us suppose that Charlie has 100.01287001 KMD (Komodo coin) in his wallet. It is comprised of three UTXOs:

| Charlie’s Initial Wallet State | Value            |
| ------------------------------ | ---------------- |
| UTXO #1:                       | 90.00000000 KMD  |
| UTXO #2:                       | 00.01287001 KMD  |
| UTXO #3:                       | 10.00000000 KMD  |
| Total                          | 100.01287001 KMD |

Charlie wants to trade 50.00 KMD on the BarterDEX network. He puts out an order for an alternate cryptocurrency called DOGE (Doge Coin), and he wants to exchange in a 1:1 ratio.

BarterDEX itself will not attempt to manage for Charlie’s misunderstanding of his UTXO inventory. (The developer of Charlie’s standalone software could try to help him, but that is a separate matter.) Rather, BarterDEX will simply look through his inventory for the largest UTXO that is below the total amount he offered. In this example, BarterDEX will select his UTXO #3, worth 10 KMD. BarterDEX will then calculate the necessary fee, which so happens to be exactly equal to the amount of UTXO #2: 0.01287001 KMD.

BarterDEX can then take these two UTXOs and facilitate a trade for DOGE in a 1:1 price ratio. Charlie’s final wallet appears as so:

| Charlie’s Final Wallet State | Value                              |
| ---------------------------- | ---------------------------------- |
| UTXO #1:                     | 90.00000000 KMD                    |
| UTXO #3:                     | 10.00000000 KMD                    |
| Total                        | 90.00000000 KMD + 90.00000000 DOGE |

It is up to Charlie, or to the creators of any standalone GUI wallet, to manage the UTXOs. BarterDEX only manages the matching of the UTXOs once they are created.

## Detailed Explanations of the Barterdex Process

With an understanding of the specifics of what BarterDEX is actually trading, we can now approach an explanation of how the trading procedure occurs.

### Atomic Swaps on The Komodo BarterDEX

To facilitate trading among users, BarterDEX implements a variation of the atomic-swap protocol, as described by Tier Nolan on BitcoinTalk.org. The original concept provided by Tier Nolan can be said to be "ahead of its time," as it is both complex and relies conceptually on technology that yet does not exist. Therefore, to create our variation of the atomic-swap protocol, we adapted for the current technology. A thorough study of Nolan’s original exposition can provide a solid background into the tradeoffs that we made as we selected our final version of our atomic-swap protocol.

We emphasize to the reader that the key aspect that we maintained from the original concept is that at each step there are both incentives to proceed to the next step in the proper manner, and disincentives to avoid abandoning the procedure. With this structure in place, regardless of where the protocol stops, each party receives their proper reward. If a party attempts to deviate from the proper path, their funding is penalized to the point of eliminating any potential rewards a user could gain by acting maliciously. These incentives and disincentives create the foundation for the requisite trustless nature of our atomic-swap protocol.

### Introducing, Alice and Bob

To understand why the atomic-swap protocol is necessary, it is first important to recall that computer code is executed in linear fashion. Even if we were to assume that both parties in a trade may be honest, on a computer the process of taking money from each digital wallet and pulling the money into the open must happen one wallet at a time. Therefore, one person must send out their money first. The atomic- swap protocol protects that person from vulnerability. Without the atomic swap, any malicious party involved (whether it be a full-relay node, trading partner, or other external agent) would be able to destroy the fairness of the trade.

There are two parties in an atomic swap: the liquidity provider and the liquidity receiver. Once the process of an atomic swap begins, the behavior of each party’s public trading profile is recorded and added to their reputation on the BarterDEX network.

The process of an atomic swap begins with the person who makes the initial request—this is the liquidity receiver. By convention, we call this person, "Alice." Alice will need two UTXOs to perform her swap. One UTXO will cover the protocol fee, which is roughly 1/777th the size of her desired order. We call this fee the `<dexfee>`, and its primary purpose is to serve as a disincentive to Alice from spamming the network with rapid requests.

The second UTXO required of Alice is the actual amount she intends to swap. BarterDEX first verifies that she has these funds, but for the moment she retains these funds in the safety of her own digital wallet.

On the other side of the atomic swap, we have the liquidity provider—we call this person, "Bob." Bob sees the request on the network for Alice’s atomic swap and decides to accept the trade. Now his part of the process begins.

To complete the trade, he must also have two UTXOs, but with one important difference: the first UTXO is equal to 112.5% of the amount that Alice requested; the second UTXO is exactly equal to the amount that Alice intends to swap. In other words, Bob must provide liquidity of 212.5% of the total amount of the currency that Alice requests.

The first UTXO (112.5%) Bob now sends out as a security deposit, placed on the BarterDEX network. The network’s encryption holds the deposit safely in view, but untouchable. We call this UTXO, `<bobdeposit>`. It will remain there until his side of the bargain completes in full, or until Alice’s request for a swap times out. Assuming Bob keeps his promises and stays alert, these funds will be automatically returned to him at the appropriate moment.

The second UTXO (100%) he retains within the safety of his own wallet for the mo- ment.Performing a successful connection between Bob and Alice, and verifying their requisite UTXOs, is the most complex and difficult aspect of creating the BarterDEX network. Myriad factors are involved in a successful attempt for Bob and Alice to connect: human motivation; the experience level of the users; economics; connection technology; user hardware setups; normal variations within Internet connections; etc.

We emphasize to users here that the process of performing these actions over a peer-to-peer network has almost an artistic element to it. An attempt to successfully connect Bob and Alice can be thought of more like fishing, where we must simply cast and recast our line until we successfully connect with our target. If a user attempts a trade and no response returns from the network, the user should slightly adjust the parameters of their offer and try again. As BarterDEX continues to iterate and improve, and as the number of users increases, we expect any required effort to lessen for users, the network, and the BarterDEX GUI apps.

### Alice and Bob Make a Deal

Assuming Alice and Bob are successfully connected, the process from this point forward becomes quite simple:

In some cases, it is possible to perform an atomic swap with fewer steps, but for the sake of brevity we will focus only on this scenario.

A summary of the procedure:

1.  Alice requests a swap and sends the `<dexfee>` to the BarterDEX full-relay nodes.

    *   The full-relay nodes receive her request and publish it to the network

2.  Bob sees the request on the network, accepts it, and sends out `<bobdeposit>`

    *   `<bobdeposit>` enters a state of limbo on the BarterDEX network, held safely by encryption, awaiting either Alice to proceed, or for the swap to time out

    *   If the latter occurs, `<bobdeposit>` is automatically refunded to Bob via the BarterDEX protocol

3.  Alice now sends her `<alicepayment>` to Bob

    *   She does not send the payment to Bob directly, but rather into a temporary holding wallet on the BarterDEX exchange, which is encrypted and protected by his private keys

    *   Only Bob has access to this wallet, via the set of privkeys that only he owns

    *   However, the BarterDEX code does not yet allow Bob to unlock this temporary holding wallet; he must continue his end of the bargain first

    *   The `<alicepayment>` will remain in Bob’s temporary holding wallet for a limited amount of time, giving him the opportunity to proceed

4.  Bob now sends his `<bobpayment>` to Alice

    *   Again, this is not sent to Alice directly, but rather into yet another temporary holding wallet

    *   Likewise, only Alice has access to the necessary privkeys for this wallet

    *   The `<bobpayment>` will automatically be refunded if she does not complete her part of the process

5.  Alice now "spends" the `<bobpayment>`

    *   By the word "spends," we simply mean that she activates her privkeys and moves all the funds to another wallet—most likely to her smart address

    *   BarterDEX registers that Alice’s temporary holding wallet successfully "spent" the funds

6.  Bob "spends" the `<alicepayment>`

    *   Likewise, Bob simply moves the entirety of the `<alicepayment>` into a wallet of his own—again, it will most typically be his own smart address
    *   BarterDEX now knows that Bob also successfully received his money

7.  Seeing both temporary holding wallets now empty, the BarterDEX protocol recognizes that the atomic swap was a complete success.

    *   BarterDEX now refunds `<bobdeposit>` back to Bob and the process is complete.

While it may seem inefficient to have seven transactions for a swap that could be done with two, the complexity of this process provides us with the requisite "trustless-ness" to maintain user safety.

### Incentives and Disincentives to Maintain Good Behavior

As we will now explain, at every step along the way there are incentives for each side to proceed, and there are various financial protections in place should one side fail. Also, because payments are sent to these "temporary holding wallets" that exist within the BarterDEX protocol, the protocol itself can assist in the process of moving money at the appropriate steps. Let us now examine what is happening at each step.

#### 1 - Alice Sends `<dexfee>`

If Bob accepts the offer to trade, but does not send `<bobdeposit>`, Alice only stands to lose her `<dexfee>` UTXO. This is only 1/777th of the entire transaction amount, so she loses very little. Bob, on the other hand, stands to lose more. Since Bob did not follow through with his end of the bargain, the BarterDEX network indicates on his public BarterDEX trading profile that he failed in a commitment, thus decreasing his profile’s reputation. If Bob continues this behavior as a habit, he may find it difficult to discover trading partners.

So long as the frequency of "Bobs" failing is low, the occasional extra `<dexfee>` paid by an Alice is a minor issue. However, if there is a sudden spike in misbehavior, the BarterDEX code has in-built contingency plans which can provide refunds to Alice(s), should a particular Alice node(s) experience a large loss via `<dexfee>`s.

#### 2 - Bob Successfully Sends `<bobdeposit>`

If Alice does not follow with her next step, the `<alicepayment>`, then Alice loses not only the `<dexfee>`, but she also receives a mark on her public BarterDEX profile. She gains nothing, and Bob has no reason to fear as `<bobdeposit>` will automatically return to him via the BarterDEX protocol.

#### 3 - Alice Successfully Sends `<alicepayment>`

If Bob does not proceed with his next step, the `<bobpayment>`, then after 4 hours Alice can simply activate a BarterDEX protocol that will allow her to claim `<bobdeposit>`. Recall that `<bobdeposit>` is 112.5% of the original intended trade; Bob has every incentive therefore to continue with his end of the bargain, and Alice has noth- ing to fear should Bob fail. She even stands to gain a 12.5% bonus, at Bob’s expense.

#### 4 - Bob Sends `<bobpayment>`

Now, if Alice does not follow by "spending" the `<bobpayment>` (i.e. taking the money out of the temporary holding wallet and into her own smart address), then after 2 hours Bob can activate a BarterDEX protocol that allows him to reclaim his `<bobpayment>` immediately. Furthermore, four hours later Bob may activate a refund of `<bobdeposit>`; Bob is safe from Alice, should she fail. For Alice, the BarterDEX protocol allows Alice to reclaim her `<alicepayment>` after Bob reclaims both of his payments.

Everything herein is recorded to the respective users’ BarterDEX trading profiles, ensuring their reputations are on the line. Recall also that the BarterDEX protocol requires each step to be performed in the proper order, thus ensuring that neither party can take any funds before the users’ appropriate moment.

Thus, at this integral stage of the process, every step of the path is intricately interconnected and maintains various levels of protection.

#### 5 - Alice Spends `<bobpayment>`

At this point, Alice is entirely through with any risk to her reputation, her `<dexfee>` payment, or of the loss of her time.

If Bob does not follow by also "spending" the `<alicepayment>`, it is of no concern to Alice because she has already received her funds. If Bob is simply sleeping and forgets to spend the `<alicepayment>`, he can only hurt himself.

Naturally, for Bob this is slightly dangerous. Bob’s best course of action is to remain alert and spend the `<alicepayment>` once it is received.

If after four hours, Bob is still sleeping, Alice can still activate the protocol that allows her to claim `<bobdeposit>`. In this scenario, she receives both the `<bobpayment>` and `<bobdeposit>`, at only the costs of the `<alicepayment>` and `<dexfee>`.

Bob can still make a later claim for the `<alicepayment>` when he regains his awareness.

#### 6 - Bob Spends `<alicepayment>`

Assuming all has gone according to plan, and having spent the `<alicepayment>`, Bob may now reclaim `<bobdeposit>`. Just as before, if Bob does not refund his own deposit, it is his loss; in four hours Alice will be able to activate a claim on `<bobdeposit>`.

#### 7 - Bob Reclaims `<bobdeposit>`

The process is complete. Alice received the `<bobpayment>`: Bob received the `<alicepayment>`: Bob has `<bobdeposit>` back in his own possession. The entire process only cost Alice the original `<dexfee>`. At each step along the way, the side that needs to take the next step is motivated to do so, with greater and greater urgency until the process is complete.

### Additional BarterDEX Atomic Swap Details

The BarterDEX implements the above series of commands in a cross-platform man- ner, enabling users to atomic-swap trade with coins of many types, including both native coin daemon’s and those that run on SPV Electrum servers. A swap that is not completed immediately can carry on while the time has not expired within the BarterDEX protocol.

Naturally, users must understand that outside forces can disable the process and thereby damage one of the users. For instance, an Internet outage for Bob could be particularly dangerous. Therefore, users are advised only to trade manageable sums that they are willing to put at risk, and only with nodes that have reliable reputations.

This atomic-swap protocol, with all its cryptographic validations and intricate key exchanges, is less than half of the difficulty Komodo experienced in creating BarterDEX. Relatively speaking, it is "easy" to do an atomic swap in isolation between two test nodes, using UTXOs that are carefully prepared for the test.

It is an entirely different matter to open this up to the public at large, including the enabling of our orderbooks and order-matching features. Due to the peer-to-peer nature of The BarterDEX, on a live network it is impossible to guarantee that a user that indicates they would like to begin a swap will receive a successful reply.

For instance, a Bob may see a potential swap that he would like to make, but by the time his attempt to accept the swap crosses the expanse of the Internet, someone else could have already accepted the swap, thus leaving Bob in his original position. There are legion scenarios wherein the initial connection can fail. Once the connection is made, however, the rest of the process maintains reliability and user safety.

Failed attempts at establishing a connection only result in the loss of a few seconds of the user’s time, and there is no cost associated with the failure. The `<dexfee>` paid by an Alice never occurs, and BarterDEX disregards Bob’s attempt to send `<bobdeposit>`.

Therefore, while we cannot guarantee that BarterDEX will always form a valid connection for each attempt at a trade, we can offer comfort in knowing that the users’ losses in these scenarios are insubstantial.

## A More Detailed Explanation of the Atomic-Swap Connection Process

The following is a brief explanation of the complex process by which BarterDEX establishes a connection between Alice and Bob.

For BarterDEX to accept a request to begin an atomic swap, the code first needs to register and create all the necessary backend elements for the `<dexfee>`, `<alicepayment>`, `<bobdeposit>`, and `<bobpayment>`. All four must be specified before BarterDEX can indicate to Alice and Bob that it can successfully support this atomic swap.

This is more complicated than it appears. As we explained earlier, most users do not understand the true nature of how funds operate in a cryptocurrency. Rather, most simply view their balance as a single conglomerate of coins that they can spend at the "satoshi level." This misperception is important to correct to understand how BarterDEX performs an atomic swap.

Naturally, because users have varying sizes of UTXOs in their wallets, the true challenge in creating BarterDEX was to create a method of maintaining a network that would coordinate each user’s list of UTXOs in their wallets, and to allow them to match with other users in trading pairs. In addition, BarterDEX also automatically calculates the appropriate mining and transaction fees for the blockchains involved, according to a speed that maintains an optimized atomic-swap process.

As we created the necessary code to make the atomic swap possible for the public, we found that it is not practical to have the user specify which UTXO pair they have sitting in their wallet when choosing to make a swap. This would also not be intuitive for the user. Furthermore, we did not even want to code a way for an Alice to know the UTXOs a Bob has available at the moment of negotiating a trade.

Instead, here is how BarterDEX deals with the complexity of matching these unbroken and mismatching UTXOs to process an atomic swap. It is important to note that users are not required to have a sophisticated understanding of the backend UTXO process, and may simply trade using either a minimal understanding of UTXO inventories, or at least rely on the support of a cleverly coded standalone BarterDEX GUI app.

Assuming Alice has already indicated she desires to perform an atomic swap, BarterDEX calculates out the proper divisions of her UTXOs, defines how they will be appropriated during the process, and sends an "Alice Request" to Bob with information regarding her pair of UTXOs (which are the `<dexfee>` and the `<alicepayment>`). Also, BarterDEX verifies her desired price and volume.

Bob, the human user (or an artificial-intelligence bot acting on his behalf), indicates that he is willing to accept the trade. The automation of the BarterDEX Bob-side protocol now takes over in the background. It validates the "Alice Request" to make sure the UTXO pair is valid, and then the Bob-side protocol scans through Bob’s UTXO inventory for the most efficient way to create both the `<bobpayment>` and `<bobdeposit>` UTXOs.

The Bob-side protocol understands that the UTXOs will not perfectly match, and it will therefore calculate the most efficient method of making any "spare change" UTXOs as needed. An additional constraint the protocol needs to consider is that the result must match the price and volume Alice wants to pay. Finally, it accounts for the requirement that `<bobdeposit>` be at least 12.5"Alice Request." (Note that BarterDEX is directly involved with managing Bob’s UTXOs, but is not involved with managing Alice’s UTXO offers.)

Once BarterDEX verifies all these conditions, the Bob-side protocol sends back a data packet, labeled "reserved," to the Alice-side protocol to indicate that all is in order. All of this is optimized andconducted in a manner that prevents the human Bob from having his funds frozen in an unnecessary deposit duty, should the human Alice find another "Bob" in the interim.

Next, the Alice-side protocol validates the "reserved" packet from the Bob-side protocol, making sure all the UTXOs are valid, and the protocol verifies that the price and volumes are acceptable according to the original intent.

Assuming everything successfully validates, the Alice-side protocol sends a "connect" packet back to the Bob-side protocol with the same parameters, indicating that her funds are now "reserved" as well.

Between the "request" being sent and the "reserved" packet being received there is a 10-second timeout which prevents Alice from making further trade requests. This gives BarterDEX the time necessary to perform all the calculations.

This 10-second timeout also provides a contribution to what we call "whale resistance" during the Komodo dICO process. Whale resistance is a way Komodo and BarterDEX resist "whales" from purchasing an entire coin supply and thus forcing an artificial market scarcity.

The Bob-side protocol now validates Alice’s "connect" packet and, assuming everything is in order, the protocol starts a new Bob-side thread of code, thus beginning the actual atomic swap. The Alice-side protocol also receives the "connect" packet, verifies, and then starts an Alice-side thread of code.

There is one more "negotiation" step that is needed between the Alice-side and Bob-side protocols: in the event the two sides to the protocol do not achieve consensus, the entire atomic swap aborts without any payments sent from either party (i.e. "no harm, no foul").

(*This final negotiation could have been included earlier, but due to the way the atomic swap organically developed during our creation process, it ended up inside the atomic-swap protocol itself.*)

The Alice-side and Bob-side protocols have now properly performed their duties, and thus completed the most challenging aspect of the atomic-swap protocol. BarterDEX returns control to the humans (or bots acting on their behalf) to send their respective payments.

### The DEX Fee: `<dexfee>`

People will notice that there is a small `<dexfee>` required as part of the BarterDEX protocol. This is 1/777 of the transaction amount and it is calibrated to make spam attacks impractical. By forcing a would-be attacker to spend real money, attacking the network becomes costly. Without this spam prevention, the BarterDEX could otherwise be attacked at the protocol level by any person performing a plethora of trade requests.

The 1/777 fee ends up being equal to 0.1287% of the `<alicepayment>`; this is already far less than the fees paid on an average centralized exchange. Also, centralized exchanges charge both sides of the trade, so even if they charge you 0.2%, they are actually harvesting 0.4% in total fees between both parties.

Furthermore, they often have fees and limitations for withdrawing funds, as well as a lengthy, challenging, or invasive registration processes. BarterDEX has none of these things. Users need only record the passphrase they create when first entering the BarterDEX software, and they are prepared to trade.

It is possible that some atomic swaps can initiate, and then fail to complete, which raises questions about what happens to the `<dexfee>`. The `<dexfee>` is the first charge in the protocol; in this sense, there is a `<dexfee>` charged for these failed atomic swaps.

However, this failure should not be looked upon in isolation. The BarterDEX pro- tocol is based on statistics. Statistically speaking, there will be some percentage of atomic swaps that start and will not complete. Let us suppose a 15% failure rate at this stage of the atomic swap (15% is three times higher than the rate of failure we currently observe in our testing). Even in this scenario, the effective `<dexfee>` cost is still only 0.15% to all Alice-side requests across the entire network.

Therefore, if you experience the loss of a `<dexfee>` transaction for an atomic swap that fails to complete (which would be due to a failure to receive a response from Bob), know that this is all part of the statistical process. If you find yourself paying more than 0.15% of your completed trades in `<dexfee>`’s, please let us know. This would be a highly unusual statistical outlier, and we will therefore want to investigate.

As an organization, when speaking generally to our audience online, we state that the `<dexfee>` is just 0.15%. In this manner, we hope to create the expectation that 0.15% is normal; if the network performs perfectly, on the other hand, users will get a blessing in the form of a lower fee, 0.1287%.

### Dealing with Confirmations

Since BarterDEX is trading permanently on blockchains (as opposed to updating an internal database of vouchers, or managing a proxy-token account balance), both sides of the trading pair need to wait and watch as miners on the respective blockchains calculate transaction confirmations.

Because the payments that occur on one blockchain will proceed regardless of the actions on the other blockchain (i.e. a confirmation failure on one chain will not stop with the other blockchain performing its duties as normal), it is therefore important that the BarterDEX protocol observe and adjust as necessary. Each side of the BarterDEX protocol (Bob-side and Alice-side) watches and attempts to provide a level of protection for the human users.

BarterDEX achieves this protection by an array of `<setconfirms>` API calls, which gives each side the option to specify how many confirmations they expect before the automated process should be satisfied on behalf of the human users’ interests. The setting for the `<setconfirms>` feature must be decided before the atomic swap begins, as the number of confirmations the users choose will persist until the process completes. If the users have differing preferences for the total `<numconfirms>` they prefer, the BarterDEX protocol automatically sets the larger of the two preferences as the requirement for both parties. Furthermore, this feature also includes a `<maxconfirms>` value to prevent one side from specifying an unreasonable or malicious number of required confirmations.

### Zero Confirmations

BarterDEX also supports a high-speed trading mode. Using this feature, a user can activate an extremely fast mode of trading: `<zeroconf>`. This initiates a form of atomic-swap trading that does not wait for any confirmations at all. When using this feature, atomic swaps can be completed in as little as three seconds. This is a high-risk endeavor, naturally, and users should exercise extreme caution when implementing it.

One potential application for the `<zeroconf>` feature is to allow groups of individuals to form their own organizations where they decide personal trust levels, and work together to correct any mistakes that are made in their accounting endeavors.

BarterDEX also features a special Trust API that users can enable for themselves and groups that they form to indicate how much they trust different traders. By default, the Trust API is set to neutral for all users. A group of users can form their own organization and develop a trusted network for trading, using the Trust API to set each other’s trader profile to Trust = Positive. In such cases, if a user, or a group of users, tells the Trust API to set another trader profile to Trust = Negative, that trader’s `<pubkey>` is blacklisted for any of the participating individuals or groups.

### Speed Mode: An Experimental Feature Using Time-Locked Deposits

Using the `<zeroconf>` protocol, we developed a new feature for the BarterDEX network that is functional, but still experimental. It is called "Speed Mode," and it adds one additional step to the Alice and Bob process.

Alice places a one-time security deposit of an amount equal to or greater than the amount she would like to actively trade without waiting for confirmations. This security deposit is sent to a conditional p2sh wallet address (presently controlled by the Komodo team). Alice indicates within her security-deposit transaction the amount of time the deposit should remain in the wallet. The p2sh wallet will lock the funds from Alice’s end until the completion of the expiration date, though the wallet will allow the Komodo team to access the funds if necessary. This is called a "time-locked deposit." After her chosen date of expiration, she can reclaim her security at any time. Note that her KMD funds continue to be eligible for earning 5.1% rewards.

This enables Alice to participate in our experimental Speed Mode feature, a fully automated protocol that tracks users’ trading activities and monitors their uncon- firmed swaps against their time-locked deposits. While using Speed Mode, Alice can trade funds of amounts smaller than her time-locked deposit. (The Bob that accepts her request must also be willing to engage in the Speed Mode feature.)

Her trading partners dynamically decrease her trust level as she trades, monitoring the amount of her unconfirmed transactions against her total security deposit. Should she reach an unconfirmed trading capacity that is roughly equal to the amount in her deposit, the protocol blocks her from participating in the Speed Mode feature until her funds obtain more clearance through notarization on their respective networks.

Should Alice attempt to cheat during any period of zero confirmations, the Komodo team can activate the p2sh wallet security deposit and deduct the amount of her offense, and a penalty fee, from her security deposit to compensate the affected parties. The remainder will be available for her to reclaim at the date of the original expiration, at the latest.

With the security deposit in place, Alice can use the Speed Mode feature to complete a trade in as little as three to five seconds. Note that this feature is new, highly experimental, and we recommend users exercise extreme caution when participat- ing. If a user cannot activate Speed Mode, BarterDEX defaults to the normal, non-`<zeroconf>` atomic-swap trading method.

### Realtime Metrics

Nodes on BarterDEX use Realtime metrics (RTmetrics) to filter the possible candidates for atomic-swap matching. All nodes track global stats via a `<stats.log>` file. This log file allows each node to self-update the list of pending swaps on the network. By nature, the BarterDEX protocol has filters that give less priority to nodes that are already occupied. Additionally, the Alice-side protocol gives less preference to Bob-side protocols that do not have enough UTXO sizes visible in the orderbook. This is a new feature, and we expect to optimize and enhance it in future iterations.

### Orderbook Propagation

When considering how prices compare between two cryptocurrencies, BarterDEX uses the convention of "base/rel," which can be translated as "base currency to rele- vant currency." The price is calculated by determining (base currency)/(relevant currency). The relevant currency is the cryptocurrency Alice is using to make the initial purchase, and the base is the currency Alice intends to buy.

To construct a public orderbook, a node needs to have price information. Since BarterDEX communicates primarily by means of pubkeys, the price for each currency must naturally be obtained from a pubkey. In the long run, for orderbook performance, we will need a specific `<txid>/<vout>` for each node, as each individual node could have hundreds of UTXOs. Currently, propagating all this information globally would use an excessive amount of bandwidth, so we therefore use a different solution. BarterDEX instead uses a hierarchical orderbook, where the skeleton of the orderbook is simply the (pubkey)/(price) for any (base)/(relevant) pair.

This means that purchasing a cryptocurrency at the (base)/(relevant) price is directly comparable to selling the cryptocurrency using (relevant)/(base) at a ratio of 1/(price).

Using the (pubkey)/(price) pairing, all that is needed to populate the orderbook skeleton is for nodes to broadcast their pubkey and price for any (base)/(rel) pair. Nodes that are running a local coin daemon therefore broadcast their lists of UTXOs, which helps to propagate the orderbook. All of this is done in the background, on-demand.

Critical information is broadcast with fully signed encryption to prevent spoofing. Thus, all nodes can verify the smart address associated with a pubkey. In this way, nodes can validate the price broadcasted. (The electrum SPV coins have their own specific SPV-validation process for all UTXOs before they can be approved for trading on BarterDEX.)

While all nodes could broadcast their UTXO lists constantly to keep them updated, this would result in the network rapidly being overrun with congestion. To eliminate this issue, BarterDEX simply relies on the (pubkey)/(prices) as this is all that is necessary to maintain useful orderbooks.

Since there are N\*N possible orderbooks (given N currencies), it is not practical to have BarterDEX configured to update all possible orderbooks constantly. Instead, orderbooks are created on the user end when requested from the raw public data. During orderbook creation, if the top entries in the orderbook do not possess any listunspent data, a request is made to the network to gather this information.

This process ensures that by the time a trade completes, there is already a request
for an orderbook, which in turn requests the listunspent data for the most likely pubkeys. The actual order-matchingprocess then iterates through the orderbook, scanning all the locally known UTXOs to find a high- probability counterparty to whom BarterDEX can then propose a "request" offer. In practice, early users on BarterDEX can currently experience nearly instantaneous responses, assuming all the parameters are properly met.

## The BarterDEX API

We created an API model that is the same for all coins—with the obvious exceptions of the electrum-API call itself, and within some of the returned JSON files that have different calls, such as "listunspent."

Furthermore, the underlying technology of BarterDEX enables the API to treat all bitcoin-protocol compatible coins with a universal-coin model. Therefore, when working with the BarterDEX API, an independent developer working to feature their coin on BarterDEX need only use the API "coin" symbol to receive the full set of BarterDEX features.

There are several feature requirements in the core code of the blockchain coin, and if these features are not included in the core there may be some limitations. For example, a coin that is not built on the Bitcoin-protocol Check Lock-Time Verify (CLTV) feature can still take advantage of the liquidity-taker side of the BarterDEX API. For a coin to work in native mode, it must also have a `<gettxout>` RPC call.

If the coin has the CLTV OP\_CODE, it can be both the liquidity provider and the liquidity taker. For coins using SPV, BarterDEX only supports the liquidity-taking side (for overall network-performance reasons). Also, we assume that any trader with ambitions of being a serious liquidity provider should also be serious enough to install the coin daemon for the coins they are trading, as this will increase their speed of processing.

### A Brief Discussion on the Future of BarterDEX

This concludes a high-level summary of the BarterDEX protocol as created by the Komodo organization. It is now fully functioning and live, and with the support of our community, we have successfully completed roughly one-hundred thousand atomic swaps.

We should warn our readers, nevertheless. Every element of the Komodo ecosystem is still considered to be highly experimental. We provide no investment advice, nor any guarantees of any funds utilized on our network. Use our products only at your own risk.

Looking past our upcoming immediate dICOs, BarterDEX will continue to evolve. The current iteration has already identified several areas of improvement for the next iteration. Several different GUI systems are also under construction by various com- munity members, all of which are utilizing the BarterDEX 1.0 API. As we develop the BarterDEX API, we are making sure that future iterations are backwards compatible for developer ease-of-use. Improving the user experience and user interface of a leading GUI app is a top priority.
export const title = "Whitepaper: Chapter-7";
export const description = "The features described on this page are deprecated and no longer available.";

The features described on this page are deprecated and no longer available.

# Abstract (Jumblr)

Jumblr is a Komodo technology that enables users to anonymize their cryptocurrencies. At its foundational level, Jumblr takes non-private funds from a transparent
(non-private) address, moves the funds through a series of private and non-traceable
zk-SNARK addresses—which disconnects the currency trail and anonymizes the
funds—and then returns the funds to a new transparent address of the user’s choosing. Through a connected Komodo technology, BarterDEX, Jumblr can provide this service not only for Komodo’s native coin, KMD, but also for any cryptocurrency connected to the Komodo ecosystem.

## Introduction

### The Option of Privacy is Essential to the Komodo Ecosystem

One primary goal of the Komodo ecosystem is to provide our users with the highest
levels of security. The option to enable oneself with privacy is an inherent part of a
strong security system. Privacy empowers users with the ability to make choices
without being directly controlled or observed by a third-party actor.

Many of humanity’s most meaningful advancements in art, technology, and other
human endeavors began in situations where the creator had the security of privacy
in which to explore, to discover, to make mistakes, and to learn thereby.

The roots of the Komodo ecosystem stem from the seminal work of Satoshi
Nakamoto and his Bitcoin protocol 1 . One of the key challenges in this technology
is that the original protocol does not make any account for privacy. Therefore, in advancing blockchain technology, we created Jumblr to empower Komodo-ecosystem
members with this necessary security.

### Challenges for Privacy-centric Systems and the Komodo Solution

Current pathways to obtain privacy in the blockchain industry have many problems.

One of the most popular methods to obtain privacy is the use of a centralized
mixing service. In this process, users send their cryptocurrencies to service providers,
who then mix all the participants’ coins together, and return the coins according to
the relevant contributions. With this method, the most dangerous issue, among many,
is that for the duration of the mixing period users lose control over their currency.
The funds, therefore, are subject to theft and human error.

Other decentralized coin-mixing methods, such as the [coin shuffle](https://bitcoinmagazine.com/articles/shuffling-coins-to-protect-privacy-and-fungibility-a-new-take-on-traditional-mixing-1465934826/) , require coordinating with other human parties. This also introduces the potential for the same
issues of theft and human error, and adds yet another risk: the coordination between
human parties can result in the disclosure of a user’s privacy.

Some cryptocurrencies support mixing as a part of the normal transaction process
out of a desire to provide constant anonymization. Varying methods for randomizing
these transaction-mixing patterns exist among the many different brands of relevant
cryptocurrencies. The most popular is Monero.

## The Komodo Solution

### An Introduction to Jumblr

Our Jumblr technology solves these issues through a two-layered approach, relying on connected technologies in the Komodo ecosystem—BarterDEX, our native
Komodo coin (KMD), and the upstream Zcash parameters. The Jumblr process is
managed locally on the user’s machine and requires no third parties, human coordination, or other mixing services.

### A Brief Explanation of the Two Foundational Technologies

#### Komodo Coin(KMD)

KMD is a cryptocurrency that enables users to conduct both transparent and private transactions. In developing the Komodo ecosystem, we use KMD as the native
cryptocurrency for many connecting technologies. KMD thereby continually gains
usefulness as more Komodo tools are built upon it, including Jumblr.

#### KMD Began as a Fork of Zcash

This coin began as a fork of the popular privacy coin, [Zcash](https://z.cash/). As such, KMD retains the same inherent privacy features. Notable among these features are the Zcash parameters and zk-SNARK technology. These enable users to move funds on a public blockchain without leaving a data trail for later analysis.

This is one of the most powerful forms of blockchain privacy in existence, as the
provided privacy is effectively permanent. The Zcash parameters and zk-SNARK
technology provide the initial foundation for users to take transparent KMD funding and make it anonymous (with the assistance of Komodo’s Jumblr technology)
without leaving behind a cryptocurrency trail.

The Zcash project itself is a fork of Bitcoin. Thus, all the features designed by
Satoshi Nakamoto in the Bitcoin protocol are also available in Komodo.

#### BarterDEX

BarterDEX is an open-source protocol designed and pioneered by the Komodo
team. It allows people to trade cryptocurrency coins without a counterparty risk. The
protocol is open-source and trading is available for any coin that developers choose
to connect to BarterDEX.

An in-depth discussion of BarterDEX is provided in the previous [Part III](/historical/whitepaper/chapter5/) section of
this paper.

#### Iguana Core

A core Komodo technology, called Iguana Core, is fundamental to the overall functionality of the Komodo ecosystem. It is at the center of nearly all Komodo projects,
and Jumblr is no exception. For more information on Iguana Core, please see our Komodo GitHub repository. There is also more detail provided in the BarterDEX section
of this whitepaper.

#### Komodod

Komodod is the name of the background software (also called a daemon) that
runs behind the scenes of essentially all Komodo-related software. There is more
information provided on Komodod in the dICO part of this paper.

## The Jumblr Process

Jumblr enables users to anonymize their funds. The Jumblr process is rooted in
our native Komodo coin (KMD), and the privacy features can extend thereby to any
blockchain project connected to the Komodo ecosystem.

### Anonymizing Native Komodo Coin (KMD)

At its most simple level, Jumblr takes non-private KMD funds from a transparent
(non-private) address, moves the funds through a series of private and non-traceable zk-SNARK addresses—which disconnects the currency trail and anonymizes the
funds—and then returns the funds to a new transparent address of the user’s choosing.

The entirety of the anonymization process is conducted through the user’s local
machine(s), with one exception—that of sending the data to the network for mining.
Therefore, Jumblr eliminates many dangers, including the issues of theft, human error,
the disclosure of user privacy through human coordination, and the unraveling of
privacy by ever-increasing nature of computer processing power.

### User Actions

The commands that initiate Jumblr exist within Komodo’s foundational program
on the user’s local machine, Komodod. This program is included in a typical Komodo
installation, and, under normal circumstances, Komodod is natively connected to the
same KMD addresses accessed by the user.

Therefore, users in the Komodo ecosystem have access to Jumblr’s privacy tech-
nology without any further effort. Developers of standalone GUI applications for the
Komodo ecosystem can integrate Jumblr commands into user interfaces in any desired manner.

There are two main commands, or API calls, available:

*   jumblr\_deposit `<KMDaddress>`

*   jumblr\_secret `<secretKMDaddress>`

#### jumblr\_deposit `<KMDaddress>`

This command initiates the anonymization of KMD.

Before executing the command, the user prepares the funds by placing them within
the chosen `<KMDaddress>`. So long as Komodod has access to the private keys of the
`<KMDaddress>`, nothingfurther is required. The user simply executes the command
"jumblr\_deposit `<KMDaddress>`" and Jumblr begins watching for and processing any
funds in the `<KMDaddress>`.

*   We call a transparent address a "T address." These are fully accessible to the user, and they are the means of conducting normal transactions. All currency entering and leaving a T address is fully visible to the network.
*   On the other hand, we call a privacy-enabled address a "Z address," as they utilize the Zcash parameters and zk-SNARK technology. Z addresses are internal to the Jumblr process and a user typically does not directly interact with them.

The first step Jumblr takes is to move the user’s funds from a T address to a Z
address.

The First Step of the Jumblr Anonymization Process

***

Moving the funds from a transparent address to a privacy-enabled address.

T -> Z

Naturally, as the T address is fully public, an outside observer can see the funds
as they leave for the respective Z address. Therefore, to fully disconnect the currency
trail, Jumblr then moves the funds from the initial Z address to yet another Z address.

Jumblr creates a new Z address for each individual lot.

The Second Step of the Jumblr Anonymization Process

***

Moving the funds from one unique and untraceable Z address to another

Z -> Z

Through the technology of the Zcash parameters, zk-SNARKs, and Jumblr, the
specific whereabouts of the funds are known only to the user. The user does not
need to follow the movements of T → Z and Z → Z. However, for the advanced user,
there are Jumblr commands available that allow for more active interaction at these
stages (see the Komodo wiki for further details). One command to mention here is
`z_gettotalbalance`. This reveals to the user the total balance they hold within all their
Z addresses.

Upon executing the command \[jumblr\_deposit `<KMDaddress>`], Jumblr begins
continually observing the `<KMDaddress>`. Should the user send more funds into
their `<KMDaddress>` while Jumblr is already processing the previous amount, Jum-
blr will simply take these new funds into account, perform any necessary actions to
properly adopt them into the process, and continue its course.

Jumblr includes two subcommands that allow the user to pause Jumblr manually:
`<jumblr_pause>` and `<jumblr_resume>`. The user can also halt Jumblr by shutting
down Komodod (and any relevant standalone GUI applications).

Once the funds have reached their final Z address(es), they lay dormant, awaiting
the user’s next command.

#### jumblr\_secret `<secretKMDaddress>`

The user executes this command to complete the Jumblr process. Jumblr will extract
all the user’s hidden currency from each Z address and place the funds in a new T
address, which we call the `<secretKMDaddress>`. This makes the funds spendable
again.

The Third and Final Step of the Jumblr Anonymization Process

***

Moving the funds from one unique and untraceable Z address to another

Z -> T

We recommend that you keep these private addresses primarily for storage. You
should never share with anyone any information regarding your `<secretKMDad- dress>`’s. Treat all relevant information like a password.

When you are prepared to spend from your private funds, we recommend that
you repeat the Jumblr process again on the amount that you desire to spend. This
will keep the bulk of your stored funds within a privacy "air gap," as it were. For
maximum privacy, we also suggest that after emptying the public node of all funds,
the user delete and destroy the wallet.dat file in which the initial privacy- creation
process took place. This destroys the last remnants of the cryptocurrency trail.

## Additional Security Layers

### Jumblr’s Process of Breaking Down Funds

The method by which Jumblr breaks down and processes the funds provides yet
another layer of privacy. Jumblr begins by taking the total amount in the `<KMDaddress>` and, if necessary, splitting it until the largest quantities are all equal to \~7770
KMD. It then breaks down the remainder into quantities of \~100 KMD, and then the
remainder thereafter into quantities of \~10 KMD. Any final remainder (which would
be anything less than \~10 KMD) is ignored.

Jumblr also automatically extracts its 0.3% overall fee during the Jumblr process.

Therefore, the total amount is broken down into lot sizes of \~7770 KMD, \~100
KMD, and \~10 KMD.

### Jumblr’s Process of Moving the Individual Lots into a Private Address

Jumblr does not immediately move each lot into a Z address. Instead, it performs
its actions in a randomized pattern to optimize anonymity, using the collective of
all Jumblr users in the Komodo ecosystem to blend the transactions of the crowd
together.

First, all Jumblr actions throughout the ecosystem are programmed to cluster
around block numbers that are multiples of ten (i.e. blockchain height = XXXXX0).
This gathers all Jumblr requests from all users for the given time into one large
group, clustered together every ten minutes (a single block generates every minute,
and therefore the tenth block occurs every tenth minute).

At the moment of activity, Jumblr does one of two things: it either performs the
next action in the process of anonymization, or it chooses to do nothing.

#### Option 1: Jumblr performs the next action

When Jumblr looks at the next action, it can perform one of three possible steps:

*   T → Z If the lot has yet to be moved out of the `<KMDaddress>`, Jumblr can move it from the first T address to the first Z address.
*   Z → Z Assuming the lot is now in the first Z address, Jumblr can move it to the final Z address.
*   Z → T Assuming the `<jumblr_secret>` API call is activated, Jumblr can move the lot from the final Z address to the final T address: `<secretKMDaddress>`.

#### Option 2: Does nothing

*   At each turn, instead of performing any of the above steps, Jumblr can simply abstain from any action. This happens approximately half of the time.

Through these actions, Jumblr adds a layer of obfuscation on top of the Zcash parameters and zk-SNARK technology by adding privacy to the timing and movements of each step for each user.

## Additional Privacy Considerations

Although the KMD anonymization process provides a measure of privacy and may
appear to be sufficient, there are still more precautions a user must take. Two main attacks are available to a would- be sleuth.

### The Timing Attack

In this attack, the sleuth simply studies the time the funds disappear from the
`<KMDaddress>` and looks for funds to appear in a T address soon thereafter. If the
privacy-user persistently chooses predictable timing for initiating and completing the
Jumblr commands, a determined sleuth might deduce a user’s `<secretKMDaddress>`.

The aforementioned process of grouping and randomizing the timing of movements provides one layer of security against The Timing Attack. Users thus blend the
timing of their movements together, using the power of the collective to obscure their
transactions from the sleuth.

However, The Timing Attack remains an issue if the user is the only person employing Jumblr for the duration of the anonymization of their funds. In this event,
effectively no anonymization takes place. The sleuth can clearly see the funds leave
from the `<KMDaddress>` and return to the`<secretKMDaddress>` later. Therefore, to
be effective, Jumblr requires more than one user and gains strength with higher levels
of adoption. Given the growing size of the Komodo community, we anticipate that
users will easily be able to overcome the Timing Attack.

### The Knapsack Attack

The Knapsack Attack is somewhat like the Timing Attack, but as applied to
amounts. For example, if there is only one KMD address that entered \~1000000 KMD
into Jumblr, and \~1000000 KMD later emerges elsewhere, the sleuth can easily discern
the user’s `<secretKMDaddress>`.

The process of breaking down the total amount into three equal sized lots (\~7770,
\~100, \~10 KMD) for all users provides one layer of security against the Knapsack
Attack. Users again can blend their transactions together, using the power of the
collective to obfuscate their movements.

Jumblr has another feature, Multiple Secret Addresses, that also protects against
this attack. This feature is explained in the following section.

### Further Security Enhancements to Combat the Timing and Knapsack Attacks

#### More Defense Against the Knapsack Attack: Multiple Secret Addresses

As another layer of security, users can create multiple secret KMD addresses (`<secretKMDaddress>`’s) and actively use them in the Jumblr process.

When using multiple `<secretKMDaddress>`’s, whenever Jumblr reaches the stage
of Z → T for any given lot of KMD, Jumblr will randomly choose one of the `<secretKMDaddress>`’s for this lot’s final T address. This enables the user to split their initial
funding into many different `<secretKMDaddress>`’s, thus providing another layer of
security against the Knapsack Attack.

Jumblr manages up to 777 `<secretKMDaddress>`’s at one time.

#### Further Enhancements Against the Timing Attack

The simplest and strongest defense against the Timing Attack is in the hands of
the users. Recall that a user chooses the times they execute the commands `<jumblr_deposit>` and `<jumblr_secret>`. The longer a user maintains their currency within
the shielded Z address(es), the more security they have against the Timing Attack.
This is because the Jumblr actions of other users during the interim obfuscate the
trail. We therefore encourage users who are mindful for protection against this attack
to delay the period of execution between the two commands.

We also developed Jumblr to have additional inherent protections against the Timing Attack for cases where users desire a more immediate transfer. Assuming Jumblr
is activated on the user’s local computer, as soon as Jumblr detects a new deposit
in the `<KMDaddress>`, it can begin the anonymization process. However, Jumblr deliberately delays its own progress to provide a layer of security against The Timing
Attack.

Recall that all user actions are clustered around block numbers that are multiples
of ten, and half the time, Jumblr decides to do nothing. Therefore, in statistical terms, although the Jumblr background process may be constantly running in Komodod,
Jumblr only activates to check for pending tasks every tenth minute, and only performs tasks every twentieth minute. Thus, each hour has roughly three different moments when Jumblr will perform one of the three available actions: T → Z, Z → Z, and
Z → T. This program randomizes the amount of time it takes to complete the Jumblr
process.

Assuming during a given period of activity Jumblr decides to perform the action
of T → Z, it begins by working through the different sizes of lots from largest to
smallest—thus beginning with a 7770-KMD lot until they are all allocated, then to
the 100-KMD lots, and finally to the 10-KMD lots. During any individual period of
activity, Jumblr will perform the T → Z movement for no more than a single lot, and
then stop.

However, when Jumblr performs either of the other two actions (Z → Z and Z → T)
it will make the transfers for all lots that are in play.

Through these additional securities, therefore, Jumblr defeats the Timing Attack
and the Knapsack Attack, relying on the power of the Zcash parameters and zk-
SNARK technology. The more participants in Jumblr, the more privacy users gain.
For those who use Jumblr on a consistent basis, the 0.3% cost of utilizing Jumblr is
offset by the 5.1% rewards that can be earned with the Komodo coin (KMD). Thus,
for a small fee, Jumblr users can provide both themselves and their community with
privacy.

## Offering Privacy to Other Cryptocurrencies

Jumblr can provide privacy to any cryptocurrency that is connected to the Komodo
ecosystem, as BarterDEX is natively integrated. Currently, the user is required to
perform the first and final steps of trading in the Jumblr process of non-KMD cryptocurrencies. In the long term, however, Jumblr is capable of fully automating the
process. We await larger adoption to complete the non-KMD automation features.

### The Current Jumblr Process: Manual non-KMD to KMD Trading on BarterDEX

Overall, to provide privacy to a non-KMD cryptocurrency in the Komodo ecosystem, that currency must first be traded on BarterDEX into KMD. Once the underlying
value is held as KMD in a `<KMDaddress>`, Jumblr can complete its work. Upon completion, the anonymized KMD is then exchanged on BarterDEX again for the relevant
non-KMD cryptocurrency and returned to a secret address of the user’s choosing.

At present, while BarterDEX is in its early stages, we are focusing our energies on increasing overall BarterDEX usability.

### Future Capabilities: Jumblr Automates the BarterDEX Trading Process for the User

In the future, Jumblr will simply be a client of the BarterDEX service when providing privacy to non-KMD cryptocurrencies.

When a user activates Jumblr for a non-KMD coin, Jumblr will instruct BarterDEX
to trade the non-KMD coin into transparent KMD according to the current prices.
The underlying value now being in KMD, the Jumblr protocol performs the entirety
of the process previously described. With the underlying value made private, Jumblr
will direct BarterDEX to exchange the value back to the user’s chosen cryptocurrency.
Finally, Jumblr will return the final sum to a new cryptocurrency address, provided
by the user at the outset of the process.

Due to market fluctuations, depending on liquidity, it is possible that a user will
experience slippage in the underlying value of their non-KMD cryptocurrency. While
it would be possible to prearrange the trade on BarterDEX (thereby eliminating any
slippage), there is no available method to make such an arrangement without leaking
privacy information. The party performing the second half of the trade onBarterDEX
would be a central point of failure. Therefore, the most private method for non-KMD privacy creation is to simply rely on the active BarterDEX liquidity providers.

## A Word on Risks Inherent in Jumblr and the Komodo Ecosystem

The Komodo coin (KMD), and therefore Jumblr by association, both rely on the
Zcash parameters as put forth by the Zcash team. The Zcash parameters are a "zero-knowledge" form of technology. This is a powerful form of privacy, and arguably
superior to other forms as it is effectively permanent. Relying on the Zcash parameters allows us to turn our creative resources to other blockchain-technology challenges, while still empowering members of the Komodo ecosystem with the option
of privacy.

To create the Zcash parameters, the original Zcash developers had to create a series
of keys that, when combined, created a master key that could unlock and lock the
parameters. After using the master key to create the parameters, the team destroyed
every individual key. The team conducted this endeavor in a public manner. We encourage interested readers to view the "Zcash Ceremony" explanation, and to search
for other viewpoints as well.

To briefly summarize the security measures, the Zcash team used several layers of
protection including: multi-party computation, air-gapped compute nodes, hard-copy
evidence trails, a uniquely crafted distribution of the Linux operating system, and
the physical destruction of each piece of hardware that held an individual key. The
resulting layers of defense would be of the highest level of difficulty for an outsider to penetrate. Furthermore, the method of creation and destruction ensured that the
internal security of the project was faultless, so long as at least one member of the
entire Zcash team was honest.

By our observation, the team performed this endeavor with sufficient competence
and due diligence. Furthermore, given the nature of the project, the longstanding
reputation of the Zcash developers, and the modus operandi of their lives’ work, we
believe they were properly motivated to perform the creation and destruction in a
capable and honest manner.

Nevertheless, there are privacy advocates in the cryptocurrency industry who maintain a degree of suspicion over any project that requires an element of human trust.
This suspicion extends to the Zcash parameters. These observers continually scrutinize the Zcash project, searching for more and more processes by which the creation
ceremony could have failed. Yet, while various theories have been put forth, no actual
failure in the Zcash parameters has been discovered.

In adopting the Zcash parameters, we receive frequent questions regarding how
they affect the Komodo coin. The answer is that the privacy in the Komodo ecosystem
is permanent, regardless of any potential fault by the Zcash team. Furthermore, we
can adopt any updates the Zcash team releases to the parameters.

In the unlikely event that someone was able to retain a complete copy of the master
key, the only power the holder would have, would be the ability to create new private
money in our system. This holder could then trade that for transparent, spendable
money. This could negatively impact the Komodo coin, and we would be required
to adapt our platform. If a fault in the Zcash parameters were to be discovered, the
Komodo team has various contingency methods at our disposal to remove the Zcash
parameters and replace them with a new set of parameters.

Though in Komodo we do not see this as a realistic threat, we nevertheless include
the information here in our white paper to provide complete transparency for any
user who seeks to invest their resources in the Komodo project.

## Jumblr Provides the Komodo Ecosystem With Privacy

For the Komodo ecosystem to reach its full potential, the option of enhanced privacy
must be available to Komodo users. Jumblr fills this demand.

Jumblr relies on BarterDEX, KMD, and Iguana Core to connect to the Komodo
ecosystem. The foundational privacy it offers is built upon the KMD coin, the Zcash
parameters, and zk-SNARK technology. Additional enhancements are built into the
Jumblr process to maximize user privacy, including protections against the Timing
Attack and the Knapsack Attack. Through BarterDEX and Iguana Core, these privacy
features extend to any cryptocurrency connected to the Komodo ecosystem.

As more users become a part of the Komodo ecosystem, they can work together to
enhance both their own privacy and the privacy of fellow ecosystem members. As the
ecosystem continues to grow, there are various levels of growth the Komodo team can
offer to Jumblr, including automating the non-KMD Jumblr process. We look forward
to receiving your feedback on this privacy-enhancing technology.
export const title = "Whitepaper: Chapter-8";
export const description = "This page concludes a thorough explanation of the foundational technologies of the Komodo ecosystem.";

# Final Notes Regarding the Komodo Project

There are few final miscellaneous topics to discuss. These include our strategy for
fiat-pegged cryptocurrencies (PAX), our outlook for smart-contract technology, and
the nature of the main chain in the Komodo ecosystem, KMD.

## Fiat-Pegged Cryptocurrencies

Our strategy towards fiat-pegged cryptocurrencies (PAX) has recently changed. Previously, we featured on our website a white paper that outlined a PAX strategy. That
former strategy was created before it was clear whether governments of the world
would embrace blockchain technology.

Today, it seems that governments are updating their philosophies and preparing
for blockchain adoption. Governments appear to be considering a need to create
blockchain-based cryptocurrencies that can be exchanged for their existing fiat currencies.

In many cases, we may be able to directly integrate these government-sponsored
fiat-to-blockchain cryptocurrencies natively in BarterDEX. Blockchain projects that
properly utilize the core security features of the Bitcoin protocol are capable of properly performing atomic swaps.

As it is possible that government-sponsored cryptocurrencies may natively inte-
grate with BarterDEX, it appears that creating our own PAX technology may be un-
necessary. We are putting all PAX endeavors on hold at this time.

## Smart Contracts on the Komodo Platform

There are several smart-contract options available in the Komodo ecosystem. The
options based on the Bitcoin protocol have been included with our technology, and indeed even with Bitcoin, since the beginning. We also recently released Crypto Conditions, Merkle Root of Merkle Root (MoM) notarizations, and Smart chain Customizations. These provide enhanced smart-contract and smart-chain functionality. All are
still in beta stages.

### Bitcoin-protocol Based Smart Contracts

A rarely known fact in the blockchain industry is that Satoshi Nakamoto included
secure and advanced smart-contract technology in the original release of the Bitcoin
protocol. Smart chains in the Komodo ecosystem can use the smart-contract capabilities native to the Bitcoin protocol, as Komodo is ultimately a fork of Bitcoin.

Various vendors and developers in the open-source community provide resources
to make this easier, though we make no specific endorsements of any product. One
example of smart-contract technology native to the Bitcoin protocol is a Conditional
Time-Locked Deposit, which our BarterDEX technology utilizes in the trading process.

### Crypto Conditions, Merkle Root of Merkle Root (MoM), and Customized Smart Chains

We are also in the process of releasing our own smart-contract technology that
greatly enhances the Komodo developer’s experience. Our smart-contract technology
is geared to be language-agnostic, meaning that any language (JavaScript, Ruby, C#,
Python, etc.) can execute smart contracts in theKomodo ecosystem. Furthermore, the
MoM technology allows for multi-chain and cross-chain smart- contract interoperability. These many features empower both smart chains as well as the main chain.

As each technology is still in the beta stages, we refrain from including detailed
documentation in our white paper. Please visit our communities to find documentation resources and to converse with our developers, if you are interested in building
on Komodo. We intend to create thorough educational experiences for these products
in due time.

Details Regarding the Primary Chain of the Komodo Ecosystem: Kmd

| Circulating Coin Supply:      | \~100000000 |
| ----------------------------- | ----------- |
| Total Coin Supply (yr. 2030): | \~200000000 |

The foundational coin of the Komodo ecosystem is named after the ecosystem itself, Komodo (KMD).

It is the most versatile coin we are building. Whenever we create new technologies
for our ecosystem, we seek to establish a relationship between the functionality of the technology and the usefulness of KMD. For instance, KMD is the native cryptocurrency for Jumblr. All other cryptocurrencies in the Komodo ecosystem that seek
to utilize Jumblr’s privacy must first be traded on BarterDEX for KMD. After the
privacy process is complete, the users then exchange KMD on BarterDEX for their
desired cryptocurrency. KMD is also the fuel for our smart-contract technology, and
MoM smart contracts store their data in the KMD main chain. These are but a few
examples of Komodo’s usefulness. Readers may discover many more by discussing
KMD with members of our community.

### Rewards

Furthermore, those who hold KMD may earn rewards of up to 5.1% annually. Any
wallet address that holds at least 10 KMD is eligible. KMD holders must simply move
their KMD once a month—even if the funds are sent back to the same address from
which they originated—in order to earn their reward. This reward is built into the
core code of Komodo.

The reward comes from an opportunity provided by our unique security system,
dPoW. The nature of the reward is rooted in the financial incentive that is typically
given to miners on a normal PoW chain. On a normal PoW, when a miner mines
a new block, the blockchain mints new coins and delivers them to the miner’s indicated wallet. For instance, on the Bitcoin blockchain, the reward for mining a new
block is currently \~12.5 BTC. In dPoW, we do not need to allocate such a high incentive to miners, as we already maintain access to the hash rate of our chosen PoW
network, Bitcoin. Therefore, when we created the KMD main chain, we recoded this
coin-minting reward to distribute 5.1% annual rewards to all holders of at least 10
KMD.

To earn rewards in the full amount of 5.1%, users must move their funds on the
blockchain at least once per month. The reward is calculated as a part of the UTXO
transfer process of this paper for details on UTXOs). The KMD code only
calculates rewards for UTXOs up to one month, and then stops. By simply sending
the full balance of a wallet to the same receiving address, a user can generate a
new UTXO. In this manner, the user can claim their current rewards, and continue
receiving them for at least one month.

The KMD 5.1% reward will continue for a period of approximately twelve to fourteen years. When Komodo’s overall coin supply reaches \~200M, this reward will also
discontinue. Specifically, the reward will cease when the KMD chain reaches a block
height of 7777777.

It is important to note that no one is forced into using KMD in our ecosystem. We
are often asked why we chose this route, as the free nature of the Komodo ecosystem
can be in direct contrast to the philosophies of many other ecosystems and exchanges.
Other ecosystems often require users use the developer’s coin.

The reason why we follow a more open practice is that we strive to adhere to the
guiding principles of decentralization and open-source technology. We want to create
a blockchain platform where people are free to use whatever is most useful for them
in their entrepreneurial endeavors. Keeping KMD as an optional element empowers
the members of the Komodo ecosystem with freedom.

## Conclusion

This concludes a thorough explanation of the foundational technologies of the Komodo ecosystem. We are working diligently to improve the user experience. While
some may say that the cryptocurrency industry is but a bubble, at Komodo we believe we have not yet begun the fight. We hope that the innovations we provide will be a meaningful contribution to the remarkable advent of blockchain, decentralization,
and open-source technologies.
export const title = "Intoduction to Komodo";
export const description = "The Komodo project focuses on empowering users with Freedom through blockchain technology.";

# Komodo (Advanced Blockchain Technology, Focused On Freedom)

## Intoduction to Komodo

The Komodo project focuses on empowering users with Freedom through
blockchain technology. There are many forms of Freedom that Komodo can provide,
and we are currently focusing on empowering two types of users: the blockchain
entrepreneur, and the average cryptocurrency investor. Together, our community of
entrepreneurs, investors, and other users form an economic ecosystem.

The foundational pillar of the Komodo ecosystem is security. Komodo provides
a unique and innovative form of security that is as strong as the Bitcoin network,
yet does not require the incredible cost. Every member of the Komodo ecosystem
receives the benefits of this security. The investor relies on it for everyday use. The entrepreneur relies on it to protect their blockchain innovation at a cost that is affordable
even to small businesses and startups.

Another of Komodo’s powerful technologies is a new method of trading cryptocurrencies directly from one person to another. It is a new kind of "decentralized exchange." Our decentralized exchange removes all forms of middlemen, vouchers, and
escrow services. It relies on an underlying concept called the "atomic swap", and we
are the leaders in this technology.

Our atomic-swap powered decentralized exchange serves both the investor and the
blockchain entrepreneur.

For the investor, they can trade cryptocurrencies without having to pass through a
centralized exchange, which can be an arduous and even dangerous process. They
also do not have to use an escrow service, voucher, nor even an intermediary
coin—not even Bitcoin. Furthermore, there is no registration process required, nor
are there any withdrawal limits. We currently support approximately 95% of the
cryptocurrencies in existence, including Bitcoin-protocol based coins, Ethereum, and
Ethereum-based ERC20 tokens.

For the entrepreneur, our decentralized exchange enables the release of new products to the world without middleman involvement. Furthermore, even entrepreneurs
who have previously built other blockchain projects outside our ecosystem can easily
feature their coin on our decentralized exchange. The only requirement is that the
blockchain product have the proper security elements in the core of the blockchain’s
code.

Komodo also has powerful privacy features built into our platform. This allows the
investor to trade and purchase goods and services within their right to privacy. It also
allows the entrepreneur to release their product, and to crowdsource funds, from an
audience that may prefer to maintain this privacy.

There are many other technologies and features in the Komodo ecosystem, and we
are experiencing a rapid growth of both entrepreneurs and investors.

This Komodo white paper provides an in-depth discussion about Komodo’s unique
security features, our decentralized exchange, the method of releasing new products
on it, and our native privacy features.

We welcome feedback from our readers. If you have any questions or concerns over
the course of reading this material, please reach out to our team directly. You may
find our contact information on our accompanying website: [https://komodoplatform.com/en/](https://komodoplatform.com/en/)

This section contains the following docs:
export const title = "Acknowledgements and References";
export const description = "This page has acknowledgements and references used in the whitepaper.";

# Acknowledgements and References

*   BarterDEX – A Practical Native DEX ( [https://github.com/SuperNETorg/komodo/wiki/barterDEX-Whitepaper-v2](https://github.com/SuperNETorg/komodo/wiki/barterDEX-Whitepaper-v2) )
*   Nakamoto Satoshi (2008): Bitcoin: A peer-to-peer electronic cash system. ( [https://bitcoin.org/en/](https://bitcoin.org/en/) )
*   Mtchl (2014): The math of Nxt forging ( [https://www.docdroid.net/ahms/forging0-4-1-pdf](https://www.docdroid.net/ahms/forging0-4-1-pdf) )
*   King Sunny, Nadal Scott (2012): PPCoin: Peer-to-Peer Crypto-Currency with Proof-of-Stake ( [https://www.peercoin.net/read/papers/peercoin-paper.pdf](https://www.peercoin.net/read/papers/peercoin-paper.pdf) )
*   Delegated Proof-of-Stake Consensus ( [https://komodoplatform.com/en/academy/delegated-proof-of-stake/](https://komodoplatform.com/en/academy/delegated-proof-of-stake/) )
*   Miers Ian, Garman Christina, Green Matthew, Rubin Aviel: Zerocoin: Anonymous Distributed E-Cash from Bitcoin ( [https://isi.jhu.edu/\~mgreen/ZerocoinOakland.pdf](https://isi.jhu.edu/~mgreen/ZerocoinOakland.pdf) )
*   Ben-Sasson Eli, Chiesa Alessandro, Garman Christina, Green Matthew, Miers Ian, Troer Eran, Virza Madars (2014): Zerocash: Decentralized Anonymous Payments from Bitcoin ( [http://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf](http://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf) )
*   Ben-Sasson Eli, Chiesa Alessandro, Green Matthew, Tromer Eran, Virza Madars (2015): Secure Sampling of Public Parameters for Succinct Zero Knowledge Proofs ( [https://www.ieee-security.org/TC/SP2015/papers-archived/6949a287.pdf](https://www.ieee-security.org/TC/SP2015/papers-archived/6949a287.pdf) )
*   NXT Community: NXT White paper (Previously available at `http://wiki.nxtcrypto.org/wiki/Whitepaper:Nxt`)
*   Larimer Daniel, Scott Ned, Zavgorodnev Valentine, Johnson Benjamin, Calfee James, Vandeberg
*   Michael (March 2016): Steem, An incentivized, blockchain-based social media platform.( [https://steem.com/SteemWhitePaper.pdf](https://steem.com/SteemWhitePaper.pdf) )
*   BitFury Group (Sep 13, 2015): Proof of Stake versus Proof of Work White Paper ( [https://bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf](https://bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf) )
